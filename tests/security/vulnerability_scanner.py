"""
Comprehensive Vulnerability Scanner Framework

This module implements a comprehensive vulnerability scanning framework for automated security
assessment, threat detection, and enterprise security validation as specified in Section 6.4.5
and Section 6.4.6 of the technical specification. The framework integrates multiple security
scanning tools and provides comprehensive vulnerability management capabilities.

Key Features:
- Custom vulnerability scanning for application-specific threats per Section 6.4.5
- Comprehensive security assessment with automated reporting per Section 6.4.5
- Enterprise security validation for compliance requirements per Section 6.4.6
- Security monitoring integration for threat visibility per Section 6.4.5
- Automated vulnerability management workflow integration per Section 6.4.5
- OWASP Top 10 and SANS Top 25 compliance validation per Section 6.4.5

Architecture Integration:
- Section 6.4.5: Security Controls Matrix with vulnerability scanning and penetration testing
- Section 6.4.6: Compliance Requirements with automated security validation and audit trails
- Section 6.6.1: Security testing approach with pytest framework and security tool integration
- Section 6.6.3: Quality Metrics with security scan enforcement and threshold management

Security Scanning Components:
- Static Application Security Testing (SAST) with Bandit and Semgrep integration
- Dynamic Application Security Testing (DAST) with OWASP ZAP and Nuclei integration
- Dependency vulnerability scanning with Safety and pip-audit integration
- Container security scanning with Trivy and Snyk integration
- Configuration security assessment with custom validators
- Infrastructure security validation with AWS Security Hub integration

Author: Flask Migration Team
Version: 1.0.0
Dependencies: bandit 1.7+, safety 3.0+, owasp-zap-api 0.0.21+, trivy 0.48+, semgrep 1.45+
Compliance: OWASP Top 10, SANS Top 25, SOC 2, ISO 27001, PCI DSS
"""

import asyncio
import json
import logging
import os
import subprocess
import tempfile
import time
from datetime import datetime, timedelta
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union, AsyncGenerator
from dataclasses import dataclass, field
from enum import Enum
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor, as_completed
import threading
import queue
from contextlib import asynccontextmanager

import pytest
import requests
import httpx
from tenacity import (
    retry,
    stop_after_attempt,
    wait_exponential_jitter,
    retry_if_exception_type,
    before_sleep_log,
    after_log
)

# Security scanning tool imports
import bandit
from bandit.core import manager as bandit_manager
from bandit.core import config as bandit_config
import safety
from safety.cli import check as safety_check
from zapv2 import ZAPv2

# Import security testing configuration and fixtures
from tests.security.conftest import (
    SecurityTestConfig,
    SecurityPayloads,
    SecurityAuditLogger,
    VulnerabilitySeverity,
    AttackCategory
)
from tests.security.security_config import (
    BanditSecurityScanner,
    SafetyDependencyScanner,
    OWASPZAPScanner,
    PenetrationTestRunner,
    ComplianceValidator,
    SecurityTestOrchestrator
)

# Configure module logger
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class ScanType(Enum):
    """Vulnerability scan types for comprehensive security assessment."""
    
    STATIC_ANALYSIS = "static_analysis"
    DEPENDENCY_SCAN = "dependency_scan"
    DYNAMIC_ANALYSIS = "dynamic_analysis"
    CONTAINER_SCAN = "container_scan"
    CONFIGURATION_SCAN = "configuration_scan"
    INFRASTRUCTURE_SCAN = "infrastructure_scan"
    PENETRATION_TEST = "penetration_test"
    COMPLIANCE_VALIDATION = "compliance_validation"


class ThreatLevel(Enum):
    """Threat severity levels for vulnerability classification."""
    
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


@dataclass
class VulnerabilityFinding:
    """
    Comprehensive vulnerability finding data structure with metadata.
    
    Represents a single security vulnerability finding with complete
    contextual information for remediation and risk assessment.
    """
    
    id: str
    title: str
    description: str
    severity: ThreatLevel
    category: str
    cwe_id: Optional[str] = None
    cvss_score: Optional[float] = None
    file_path: Optional[str] = None
    line_number: Optional[int] = None
    evidence: Optional[str] = None
    remediation: Optional[str] = None
    references: List[str] = field(default_factory=list)
    tags: List[str] = field(default_factory=list)
    scan_type: Optional[ScanType] = None
    discovered_at: datetime = field(default_factory=datetime.utcnow)
    false_positive: bool = False
    risk_score: Optional[int] = None
    exploitability: Optional[str] = None
    business_impact: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert finding to dictionary for serialization."""
        return {
            'id': self.id,
            'title': self.title,
            'description': self.description,
            'severity': self.severity.value,
            'category': self.category,
            'cwe_id': self.cwe_id,
            'cvss_score': self.cvss_score,
            'file_path': self.file_path,
            'line_number': self.line_number,
            'evidence': self.evidence,
            'remediation': self.remediation,
            'references': self.references,
            'tags': self.tags,
            'scan_type': self.scan_type.value if self.scan_type else None,
            'discovered_at': self.discovered_at.isoformat(),
            'false_positive': self.false_positive,
            'risk_score': self.risk_score,
            'exploitability': self.exploitability,
            'business_impact': self.business_impact
        }


@dataclass
class ScanResult:
    """
    Comprehensive scan result containing findings and metadata.
    
    Represents the complete results of a security scan execution
    with metrics, findings, and execution metadata.
    """
    
    scan_id: str
    scan_type: ScanType
    target: str
    start_time: datetime
    end_time: Optional[datetime] = None
    status: str = "running"
    findings: List[VulnerabilityFinding] = field(default_factory=list)
    metrics: Dict[str, Any] = field(default_factory=dict)
    configuration: Dict[str, Any] = field(default_factory=dict)
    errors: List[str] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)
    
    @property
    def duration(self) -> timedelta:
        """Calculate scan execution duration."""
        end = self.end_time or datetime.utcnow()
        return end - self.start_time
    
    @property
    def finding_count_by_severity(self) -> Dict[str, int]:
        """Get finding count grouped by severity level."""
        counts = {level.value: 0 for level in ThreatLevel}
        for finding in self.findings:
            counts[finding.severity.value] += 1
        return counts
    
    @property
    def critical_findings(self) -> List[VulnerabilityFinding]:
        """Get critical severity findings."""
        return [f for f in self.findings if f.severity == ThreatLevel.CRITICAL]
    
    @property
    def high_findings(self) -> List[VulnerabilityFinding]:
        """Get high severity findings."""
        return [f for f in self.findings if f.severity == ThreatLevel.HIGH]
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert scan result to dictionary for serialization."""
        return {
            'scan_id': self.scan_id,
            'scan_type': self.scan_type.value,
            'target': self.target,
            'start_time': self.start_time.isoformat(),
            'end_time': self.end_time.isoformat() if self.end_time else None,
            'status': self.status,
            'duration': str(self.duration),
            'findings': [f.to_dict() for f in self.findings],
            'finding_count_by_severity': self.finding_count_by_severity,
            'metrics': self.metrics,
            'configuration': self.configuration,
            'errors': self.errors,
            'warnings': self.warnings
        }


class VulnerabilityDatabase:
    """
    Comprehensive vulnerability database for finding management and deduplication.
    
    Manages vulnerability findings across multiple scan types with intelligent
    deduplication, false positive tracking, and risk assessment capabilities.
    """
    
    def __init__(self):
        """Initialize vulnerability database with storage and indexing."""
        self.findings: Dict[str, VulnerabilityFinding] = {}
        self.scan_results: Dict[str, ScanResult] = {}
        self.false_positives: set = set()
        self.remediated_findings: set = set()
        self.risk_assessments: Dict[str, Dict[str, Any]] = {}
        self.suppression_rules: List[Dict[str, Any]] = []
        self.logger = logging.getLogger(f"{__name__}.VulnerabilityDatabase")
    
    def add_finding(self, finding: VulnerabilityFinding) -> bool:
        """
        Add vulnerability finding with deduplication and validation.
        
        Args:
            finding: Vulnerability finding to add
            
        Returns:
            bool: True if finding was added, False if duplicate
        """
        # Check if finding already exists (deduplication)
        if finding.id in self.findings:
            existing = self.findings[finding.id]
            # Update with latest information if newer
            if finding.discovered_at > existing.discovered_at:
                self.findings[finding.id] = finding
                self.logger.info(f"Updated existing finding: {finding.id}")
                return True
            return False
        
        # Check suppression rules
        if self._is_suppressed(finding):
            self.logger.info(f"Finding suppressed by rules: {finding.id}")
            return False
        
        # Add new finding
        self.findings[finding.id] = finding
        self.logger.info(f"Added new finding: {finding.id} - {finding.severity.value}")
        return True
    
    def add_scan_result(self, scan_result: ScanResult) -> None:
        """
        Add scan result and process all findings.
        
        Args:
            scan_result: Complete scan result with findings
        """
        self.scan_results[scan_result.scan_id] = scan_result
        
        # Process all findings in the scan result
        for finding in scan_result.findings:
            self.add_finding(finding)
        
        self.logger.info(
            f"Added scan result: {scan_result.scan_id} "
            f"with {len(scan_result.findings)} findings"
        )
    
    def mark_false_positive(self, finding_id: str, reason: str = "") -> bool:
        """
        Mark finding as false positive with reasoning.
        
        Args:
            finding_id: ID of finding to mark as false positive
            reason: Reason for false positive classification
            
        Returns:
            bool: True if successfully marked
        """
        if finding_id in self.findings:
            self.findings[finding_id].false_positive = True
            self.false_positives.add(finding_id)
            self.logger.info(f"Marked finding as false positive: {finding_id} - {reason}")
            return True
        return False
    
    def mark_remediated(self, finding_id: str, remediation_details: str = "") -> bool:
        """
        Mark finding as remediated with details.
        
        Args:
            finding_id: ID of finding to mark as remediated
            remediation_details: Details of remediation action
            
        Returns:
            bool: True if successfully marked
        """
        if finding_id in self.findings:
            self.remediated_findings.add(finding_id)
            self.logger.info(f"Marked finding as remediated: {finding_id}")
            return True
        return False
    
    def add_suppression_rule(self, rule: Dict[str, Any]) -> None:
        """
        Add suppression rule for automatic finding filtering.
        
        Args:
            rule: Suppression rule configuration
        """
        self.suppression_rules.append(rule)
        self.logger.info(f"Added suppression rule: {rule}")
    
    def _is_suppressed(self, finding: VulnerabilityFinding) -> bool:
        """Check if finding matches any suppression rules."""
        for rule in self.suppression_rules:
            if self._matches_rule(finding, rule):
                return True
        return False
    
    def _matches_rule(self, finding: VulnerabilityFinding, rule: Dict[str, Any]) -> bool:
        """Check if finding matches specific suppression rule."""
        # Rule matching logic
        if 'severity' in rule and finding.severity.value not in rule['severity']:
            return False
        if 'category' in rule and finding.category not in rule['category']:
            return False
        if 'file_pattern' in rule and finding.file_path:
            import re
            if not re.search(rule['file_pattern'], finding.file_path):
                return False
        if 'cwe_ids' in rule and finding.cwe_id not in rule['cwe_ids']:
            return False
        return True
    
    def get_active_findings(self) -> List[VulnerabilityFinding]:
        """Get all active findings (not false positive or remediated)."""
        return [
            finding for finding_id, finding in self.findings.items()
            if not finding.false_positive 
            and finding_id not in self.remediated_findings
        ]
    
    def get_findings_by_severity(self, severity: ThreatLevel) -> List[VulnerabilityFinding]:
        """Get findings filtered by severity level."""
        return [
            finding for finding in self.get_active_findings()
            if finding.severity == severity
        ]
    
    def get_findings_by_category(self, category: str) -> List[VulnerabilityFinding]:
        """Get findings filtered by category."""
        return [
            finding for finding in self.get_active_findings()
            if finding.category == category
        ]
    
    def get_scan_summary(self) -> Dict[str, Any]:
        """Get comprehensive scan summary with metrics."""
        active_findings = self.get_active_findings()
        
        severity_counts = {level.value: 0 for level in ThreatLevel}
        category_counts = {}
        scan_type_counts = {}
        
        for finding in active_findings:
            severity_counts[finding.severity.value] += 1
            
            if finding.category not in category_counts:
                category_counts[finding.category] = 0
            category_counts[finding.category] += 1
            
            if finding.scan_type:
                scan_type = finding.scan_type.value
                if scan_type not in scan_type_counts:
                    scan_type_counts[scan_type] = 0
                scan_type_counts[scan_type] += 1
        
        return {
            'total_findings': len(active_findings),
            'total_scans': len(self.scan_results),
            'false_positives': len(self.false_positives),
            'remediated_findings': len(self.remediated_findings),
            'severity_distribution': severity_counts,
            'category_distribution': category_counts,
            'scan_type_distribution': scan_type_counts,
            'risk_score': self._calculate_overall_risk_score(active_findings),
            'compliance_status': self._assess_compliance_status(active_findings)
        }
    
    def _calculate_overall_risk_score(self, findings: List[VulnerabilityFinding]) -> int:
        """Calculate overall risk score based on findings."""
        risk_weights = {
            ThreatLevel.CRITICAL: 10,
            ThreatLevel.HIGH: 7,
            ThreatLevel.MEDIUM: 4,
            ThreatLevel.LOW: 2,
            ThreatLevel.INFO: 1
        }
        
        total_score = sum(
            risk_weights.get(finding.severity, 1) for finding in findings
        )
        
        # Normalize to 0-100 scale
        max_possible = len(findings) * risk_weights[ThreatLevel.CRITICAL]
        if max_possible == 0:
            return 0
        
        return min(100, int((total_score / max_possible) * 100))
    
    def _assess_compliance_status(self, findings: List[VulnerabilityFinding]) -> Dict[str, Any]:
        """Assess compliance status based on findings."""
        critical_count = len([f for f in findings if f.severity == ThreatLevel.CRITICAL])
        high_count = len([f for f in findings if f.severity == ThreatLevel.HIGH])
        
        # Compliance thresholds based on enterprise requirements
        compliance_status = {
            'soc2_compliant': critical_count == 0 and high_count <= 5,
            'iso27001_compliant': critical_count == 0 and high_count <= 3,
            'pci_dss_compliant': critical_count == 0 and high_count == 0,
            'owasp_top10_coverage': self._check_owasp_coverage(findings),
            'sans_top25_coverage': self._check_sans_coverage(findings)
        }
        
        return compliance_status
    
    def _check_owasp_coverage(self, findings: List[VulnerabilityFinding]) -> Dict[str, Any]:
        """Check OWASP Top 10 coverage in findings."""
        owasp_categories = [
            'A01_2021_Broken_Access_Control',
            'A02_2021_Cryptographic_Failures',
            'A03_2021_Injection',
            'A04_2021_Insecure_Design',
            'A05_2021_Security_Misconfiguration',
            'A06_2021_Vulnerable_Components',
            'A07_2021_Identification_Authentication_Failures',
            'A08_2021_Software_Data_Integrity_Failures',
            'A09_2021_Security_Logging_Monitoring_Failures',
            'A10_2021_Server_Side_Request_Forgery'
        ]
        
        covered_categories = set()
        for finding in findings:
            for category in owasp_categories:
                if category.lower() in finding.category.lower():
                    covered_categories.add(category)
        
        return {
            'total_categories': len(owasp_categories),
            'covered_categories': len(covered_categories),
            'coverage_percentage': (len(covered_categories) / len(owasp_categories)) * 100,
            'covered_list': list(covered_categories)
        }
    
    def _check_sans_coverage(self, findings: List[VulnerabilityFinding]) -> Dict[str, Any]:
        """Check SANS Top 25 coverage in findings."""
        sans_cwes = [
            'CWE-79', 'CWE-89', 'CWE-20', 'CWE-125', 'CWE-78',
            'CWE-416', 'CWE-22', 'CWE-352', 'CWE-434', 'CWE-862',
            'CWE-476', 'CWE-287', 'CWE-190', 'CWE-502', 'CWE-77',
            'CWE-119', 'CWE-798', 'CWE-787', 'CWE-122', 'CWE-276',
            'CWE-200', 'CWE-522', 'CWE-732', 'CWE-611', 'CWE-918'
        ]
        
        covered_cwes = set()
        for finding in findings:
            if finding.cwe_id and finding.cwe_id in sans_cwes:
                covered_cwes.add(finding.cwe_id)
        
        return {
            'total_cwes': len(sans_cwes),
            'covered_cwes': len(covered_cwes),
            'coverage_percentage': (len(covered_cwes) / len(sans_cwes)) * 100,
            'covered_list': list(covered_cwes)
        }


class SecurityScanner:
    """
    Comprehensive security scanner integrating multiple scanning tools.
    
    Provides unified interface for static analysis, dynamic testing,
    dependency scanning, container security, and compliance validation.
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        Initialize comprehensive security scanner.
        
        Args:
            config: Optional scanner configuration
        """
        self.config = config or {}
        self.logger = logging.getLogger(f"{__name__}.SecurityScanner")
        self.vulnerability_db = VulnerabilityDatabase()
        self.scan_queue = queue.Queue()
        self.active_scans: Dict[str, ScanResult] = {}
        
        # Initialize scanning components
        self._initialize_scanners()
        
        # Load suppression rules
        self._load_suppression_rules()
    
    def _initialize_scanners(self) -> None:
        """Initialize all security scanning components."""
        try:
            from tests.security.security_config import SecurityTestConfig
            self.security_config = SecurityTestConfig()
            
            # Initialize individual scanners
            self.bandit_scanner = BanditSecurityScanner(self.security_config)
            self.safety_scanner = SafetyDependencyScanner(self.security_config)
            self.zap_scanner = OWASPZAPScanner(self.security_config)
            self.penetration_tester = PenetrationTestRunner(self.security_config)
            self.compliance_validator = ComplianceValidator(self.security_config)
            
            self.logger.info("Security scanners initialized successfully")
            
        except Exception as e:
            self.logger.error(f"Failed to initialize scanners: {str(e)}")
            raise
    
    def _load_suppression_rules(self) -> None:
        """Load vulnerability suppression rules from configuration."""
        suppression_file = self.config.get('suppression_file', '.vulnerability_suppressions.json')
        
        if os.path.exists(suppression_file):
            try:
                with open(suppression_file, 'r') as f:
                    rules = json.load(f)
                    for rule in rules.get('suppressions', []):
                        self.vulnerability_db.add_suppression_rule(rule)
                self.logger.info(f"Loaded {len(rules.get('suppressions', []))} suppression rules")
            except Exception as e:
                self.logger.warning(f"Failed to load suppression rules: {str(e)}")
    
    async def run_comprehensive_scan(
        self,
        target: str,
        scan_types: Optional[List[ScanType]] = None,
        parallel: bool = True
    ) -> Dict[str, ScanResult]:
        """
        Run comprehensive security scan across multiple scan types.
        
        Args:
            target: Target for scanning (file path, URL, etc.)
            scan_types: Specific scan types to run (default: all)
            parallel: Whether to run scans in parallel
            
        Returns:
            Dict mapping scan type to scan results
        """
        if scan_types is None:
            scan_types = list(ScanType)
        
        self.logger.info(f"Starting comprehensive security scan for target: {target}")
        
        scan_results = {}
        
        if parallel:
            # Run scans in parallel for better performance
            tasks = []
            for scan_type in scan_types:
                task = asyncio.create_task(self._run_scan_async(scan_type, target))
                tasks.append((scan_type, task))
            
            for scan_type, task in tasks:
                try:
                    result = await task
                    scan_results[scan_type.value] = result
                    self.vulnerability_db.add_scan_result(result)
                except Exception as e:
                    self.logger.error(f"Scan {scan_type.value} failed: {str(e)}")
                    scan_results[scan_type.value] = self._create_error_result(
                        scan_type, target, str(e)
                    )
        else:
            # Run scans sequentially
            for scan_type in scan_types:
                try:
                    result = await self._run_scan_async(scan_type, target)
                    scan_results[scan_type.value] = result
                    self.vulnerability_db.add_scan_result(result)
                except Exception as e:
                    self.logger.error(f"Scan {scan_type.value} failed: {str(e)}")
                    scan_results[scan_type.value] = self._create_error_result(
                        scan_type, target, str(e)
                    )
        
        self.logger.info(f"Comprehensive scan completed with {len(scan_results)} scan types")
        return scan_results
    
    async def _run_scan_async(self, scan_type: ScanType, target: str) -> ScanResult:
        """
        Run individual security scan asynchronously.
        
        Args:
            scan_type: Type of security scan to perform
            target: Target for scanning
            
        Returns:
            ScanResult: Complete scan results with findings
        """
        scan_id = f"{scan_type.value}_{int(time.time())}"
        start_time = datetime.utcnow()
        
        self.logger.info(f"Starting {scan_type.value} scan: {scan_id}")
        
        try:
            if scan_type == ScanType.STATIC_ANALYSIS:
                findings = await self._run_static_analysis(target)
            elif scan_type == ScanType.DEPENDENCY_SCAN:
                findings = await self._run_dependency_scan(target)
            elif scan_type == ScanType.DYNAMIC_ANALYSIS:
                findings = await self._run_dynamic_analysis(target)
            elif scan_type == ScanType.CONTAINER_SCAN:
                findings = await self._run_container_scan(target)
            elif scan_type == ScanType.CONFIGURATION_SCAN:
                findings = await self._run_configuration_scan(target)
            elif scan_type == ScanType.INFRASTRUCTURE_SCAN:
                findings = await self._run_infrastructure_scan(target)
            elif scan_type == ScanType.PENETRATION_TEST:
                findings = await self._run_penetration_test(target)
            elif scan_type == ScanType.COMPLIANCE_VALIDATION:
                findings = await self._run_compliance_validation(target)
            else:
                raise ValueError(f"Unsupported scan type: {scan_type}")
            
            result = ScanResult(
                scan_id=scan_id,
                scan_type=scan_type,
                target=target,
                start_time=start_time,
                end_time=datetime.utcnow(),
                status="completed",
                findings=findings
            )
            
            self.logger.info(
                f"Scan {scan_id} completed successfully with {len(findings)} findings"
            )
            
            return result
            
        except Exception as e:
            self.logger.error(f"Scan {scan_id} failed: {str(e)}")
            return self._create_error_result(scan_type, target, str(e), scan_id, start_time)
    
    async def _run_static_analysis(self, target: str) -> List[VulnerabilityFinding]:
        """Run static application security testing (SAST)."""
        findings = []
        
        # Bandit static analysis
        try:
            bandit_result = self.bandit_scanner.run_security_scan(target)
            findings.extend(self._convert_bandit_findings(bandit_result))
        except Exception as e:
            self.logger.error(f"Bandit scan failed: {str(e)}")
        
        # Additional SAST tools integration
        await self._run_semgrep_scan(target, findings)
        await self._run_custom_sast_rules(target, findings)
        
        return findings
    
    async def _run_dependency_scan(self, target: str) -> List[VulnerabilityFinding]:
        """Run dependency vulnerability scanning."""
        findings = []
        
        # Safety dependency scan
        try:
            safety_result = self.safety_scanner.run_dependency_scan()
            findings.extend(self._convert_safety_findings(safety_result))
        except Exception as e:
            self.logger.error(f"Safety scan failed: {str(e)}")
        
        # pip-audit integration
        await self._run_pip_audit(target, findings)
        
        return findings
    
    async def _run_dynamic_analysis(self, target: str) -> List[VulnerabilityFinding]:
        """Run dynamic application security testing (DAST)."""
        findings = []
        
        # OWASP ZAP scanning
        try:
            if target.startswith('http'):
                zap_result = self.zap_scanner.run_security_scan(target)
                findings.extend(self._convert_zap_findings(zap_result))
        except Exception as e:
            self.logger.error(f"ZAP scan failed: {str(e)}")
        
        # Nuclei integration
        await self._run_nuclei_scan(target, findings)
        
        return findings
    
    async def _run_container_scan(self, target: str) -> List[VulnerabilityFinding]:
        """Run container security scanning."""
        findings = []
        
        # Trivy container scanning
        await self._run_trivy_scan(target, findings)
        
        # Docker security best practices check
        await self._run_docker_security_check(target, findings)
        
        return findings
    
    async def _run_configuration_scan(self, target: str) -> List[VulnerabilityFinding]:
        """Run configuration security assessment."""
        findings = []
        
        # Flask configuration security check
        await self._run_flask_config_check(target, findings)
        
        # Environment variable security check
        await self._run_env_security_check(target, findings)
        
        # TLS/SSL configuration check
        await self._run_tls_config_check(target, findings)
        
        return findings
    
    async def _run_infrastructure_scan(self, target: str) -> List[VulnerabilityFinding]:
        """Run infrastructure security scanning."""
        findings = []
        
        # AWS Security Hub integration
        await self._run_aws_security_hub_check(target, findings)
        
        # Network security assessment
        await self._run_network_security_check(target, findings)
        
        return findings
    
    async def _run_penetration_test(self, target: str) -> List[VulnerabilityFinding]:
        """Run penetration testing scenarios."""
        findings = []
        
        try:
            if target.startswith('http'):
                pentest_result = self.penetration_tester.run_penetration_tests(target)
                findings.extend(self._convert_pentest_findings(pentest_result))
        except Exception as e:
            self.logger.error(f"Penetration test failed: {str(e)}")
        
        return findings
    
    async def _run_compliance_validation(self, target: str) -> List[VulnerabilityFinding]:
        """Run compliance validation checks."""
        findings = []
        
        try:
            # Mock scan results for compliance validation
            mock_scan_results = {
                'bandit': {'vulnerabilities': []},
                'safety': {'vulnerabilities': []},
                'zap': {'alerts': {'alerts': []}}
            }
            
            compliance_result = self.compliance_validator.validate_compliance(mock_scan_results)
            findings.extend(self._convert_compliance_findings(compliance_result))
        except Exception as e:
            self.logger.error(f"Compliance validation failed: {str(e)}")
        
        return findings
    
    async def _run_semgrep_scan(self, target: str, findings: List[VulnerabilityFinding]) -> None:
        """Run Semgrep static analysis."""
        try:
            cmd = ['semgrep', '--config=auto', '--json', target]
            result = await self._run_subprocess(cmd)
            
            if result['returncode'] == 0:
                semgrep_data = json.loads(result['stdout'])
                for finding in semgrep_data.get('results', []):
                    vuln_finding = VulnerabilityFinding(
                        id=f"semgrep_{finding.get('check_id', 'unknown')}_{hash(finding.get('path', ''))}",
                        title=finding.get('message', 'Semgrep Finding'),
                        description=finding.get('extra', {}).get('message', ''),
                        severity=self._map_semgrep_severity(finding.get('extra', {}).get('severity', 'INFO')),
                        category='static_analysis',
                        file_path=finding.get('path'),
                        line_number=finding.get('start', {}).get('line'),
                        evidence=finding.get('extra', {}).get('lines', ''),
                        remediation=finding.get('extra', {}).get('fix', ''),
                        scan_type=ScanType.STATIC_ANALYSIS
                    )
                    findings.append(vuln_finding)
        except Exception as e:
            self.logger.warning(f"Semgrep scan failed: {str(e)}")
    
    async def _run_custom_sast_rules(self, target: str, findings: List[VulnerabilityFinding]) -> None:
        """Run custom SAST rules for Flask-specific security issues."""
        try:
            # Custom Flask security pattern checks
            flask_patterns = [
                {
                    'pattern': r'app\.run\(.*debug=True.*\)',
                    'title': 'Debug Mode Enabled in Production',
                    'severity': ThreatLevel.HIGH,
                    'category': 'configuration',
                    'cwe_id': 'CWE-489'
                },
                {
                    'pattern': r'SECRET_KEY\s*=\s*["\'].*["\']',
                    'title': 'Hardcoded Secret Key',
                    'severity': ThreatLevel.CRITICAL,
                    'category': 'cryptography',
                    'cwe_id': 'CWE-798'
                },
                {
                    'pattern': r'app\.config\[.*\]\s*=\s*request\.',
                    'title': 'Direct Request Data in Configuration',
                    'severity': ThreatLevel.MEDIUM,
                    'category': 'injection',
                    'cwe_id': 'CWE-20'
                }
            ]
            
            await self._scan_patterns(target, flask_patterns, findings)
            
        except Exception as e:
            self.logger.warning(f"Custom SAST rules failed: {str(e)}")
    
    async def _run_pip_audit(self, target: str, findings: List[VulnerabilityFinding]) -> None:
        """Run pip-audit for dependency vulnerability scanning."""
        try:
            cmd = ['pip-audit', '--format=json', '--requirement', 'requirements.txt']
            result = await self._run_subprocess(cmd)
            
            if result['returncode'] == 0:
                audit_data = json.loads(result['stdout'])
                for vuln in audit_data.get('vulnerabilities', []):
                    vuln_finding = VulnerabilityFinding(
                        id=f"pip_audit_{vuln.get('id', 'unknown')}",
                        title=f"Vulnerable dependency: {vuln.get('package', 'unknown')}",
                        description=vuln.get('description', ''),
                        severity=self._map_pip_audit_severity(vuln.get('fix_versions', [])),
                        category='dependency',
                        evidence=f"Package: {vuln.get('package')} Version: {vuln.get('installed_version')}",
                        remediation=f"Upgrade to: {', '.join(vuln.get('fix_versions', []))}",
                        references=[vuln.get('id', '')],
                        scan_type=ScanType.DEPENDENCY_SCAN
                    )
                    findings.append(vuln_finding)
        except Exception as e:
            self.logger.warning(f"pip-audit failed: {str(e)}")
    
    async def _run_nuclei_scan(self, target: str, findings: List[VulnerabilityFinding]) -> None:
        """Run Nuclei vulnerability scanner."""
        try:
            if target.startswith('http'):
                cmd = ['nuclei', '-u', target, '-json']
                result = await self._run_subprocess(cmd)
                
                if result['returncode'] == 0:
                    for line in result['stdout'].split('\n'):
                        if line.strip():
                            nuclei_data = json.loads(line)
                            vuln_finding = VulnerabilityFinding(
                                id=f"nuclei_{nuclei_data.get('template-id', 'unknown')}",
                                title=nuclei_data.get('info', {}).get('name', 'Nuclei Finding'),
                                description=nuclei_data.get('info', {}).get('description', ''),
                                severity=self._map_nuclei_severity(nuclei_data.get('info', {}).get('severity', 'info')),
                                category='dynamic_analysis',
                                evidence=nuclei_data.get('matched-at', ''),
                                references=nuclei_data.get('info', {}).get('reference', []),
                                tags=nuclei_data.get('info', {}).get('tags', []),
                                scan_type=ScanType.DYNAMIC_ANALYSIS
                            )
                            findings.append(vuln_finding)
        except Exception as e:
            self.logger.warning(f"Nuclei scan failed: {str(e)}")
    
    async def _run_trivy_scan(self, target: str, findings: List[VulnerabilityFinding]) -> None:
        """Run Trivy container security scan."""
        try:
            cmd = ['trivy', 'image', '--format', 'json', target]
            result = await self._run_subprocess(cmd)
            
            if result['returncode'] == 0:
                trivy_data = json.loads(result['stdout'])
                for result_item in trivy_data.get('Results', []):
                    for vuln in result_item.get('Vulnerabilities', []):
                        vuln_finding = VulnerabilityFinding(
                            id=f"trivy_{vuln.get('VulnerabilityID', 'unknown')}",
                            title=f"Container vulnerability: {vuln.get('VulnerabilityID', 'Unknown')}",
                            description=vuln.get('Description', ''),
                            severity=self._map_trivy_severity(vuln.get('Severity', 'UNKNOWN')),
                            category='container',
                            cvss_score=vuln.get('CVSS', {}).get('nvd', {}).get('V3Score'),
                            evidence=f"Package: {vuln.get('PkgName')} Version: {vuln.get('InstalledVersion')}",
                            remediation=f"Fixed in version: {vuln.get('FixedVersion', 'N/A')}",
                            references=[vuln.get('PrimaryURL', '')],
                            scan_type=ScanType.CONTAINER_SCAN
                        )
                        findings.append(vuln_finding)
        except Exception as e:
            self.logger.warning(f"Trivy scan failed: {str(e)}")
    
    async def _run_docker_security_check(self, target: str, findings: List[VulnerabilityFinding]) -> None:
        """Run Docker security best practices check."""
        try:
            dockerfile_path = os.path.join(target, 'Dockerfile')
            if os.path.exists(dockerfile_path):
                with open(dockerfile_path, 'r') as f:
                    dockerfile_content = f.read()
                
                # Check common Docker security issues
                docker_checks = [
                    {
                        'pattern': r'FROM.*:latest',
                        'title': 'Using latest tag in Docker image',
                        'severity': ThreatLevel.MEDIUM,
                        'category': 'container'
                    },
                    {
                        'pattern': r'RUN.*sudo',
                        'title': 'Using sudo in Docker container',
                        'severity': ThreatLevel.HIGH,
                        'category': 'container'
                    },
                    {
                        'pattern': r'USER\s+root',
                        'title': 'Running as root user',
                        'severity': ThreatLevel.HIGH,
                        'category': 'container'
                    }
                ]
                
                for check in docker_checks:
                    import re
                    if re.search(check['pattern'], dockerfile_content, re.IGNORECASE):
                        vuln_finding = VulnerabilityFinding(
                            id=f"docker_{hash(check['pattern'])}",
                            title=check['title'],
                            description=f"Docker security issue: {check['title']}",
                            severity=check['severity'],
                            category=check['category'],
                            file_path=dockerfile_path,
                            scan_type=ScanType.CONTAINER_SCAN
                        )
                        findings.append(vuln_finding)
        except Exception as e:
            self.logger.warning(f"Docker security check failed: {str(e)}")
    
    async def _run_flask_config_check(self, target: str, findings: List[VulnerabilityFinding]) -> None:
        """Run Flask-specific configuration security checks."""
        try:
            # Check Flask application configuration files
            config_files = ['config.py', 'app.py', 'settings.py']
            
            for config_file in config_files:
                config_path = os.path.join(target, config_file)
                if os.path.exists(config_path):
                    with open(config_path, 'r') as f:
                        config_content = f.read()
                    
                    flask_security_checks = [
                        {
                            'pattern': r'DEBUG\s*=\s*True',
                            'title': 'Debug mode enabled',
                            'severity': ThreatLevel.HIGH,
                            'category': 'configuration',
                            'cwe_id': 'CWE-489'
                        },
                        {
                            'pattern': r'TESTING\s*=\s*True',
                            'title': 'Testing mode enabled in production',
                            'severity': ThreatLevel.MEDIUM,
                            'category': 'configuration'
                        },
                        {
                            'pattern': r'SESSION_COOKIE_SECURE\s*=\s*False',
                            'title': 'Insecure session cookie configuration',
                            'severity': ThreatLevel.HIGH,
                            'category': 'session_management',
                            'cwe_id': 'CWE-614'
                        },
                        {
                            'pattern': r'SESSION_COOKIE_HTTPONLY\s*=\s*False',
                            'title': 'Session cookie not HTTP-only',
                            'severity': ThreatLevel.MEDIUM,
                            'category': 'session_management',
                            'cwe_id': 'CWE-1004'
                        }
                    ]
                    
                    for check in flask_security_checks:
                        import re
                        if re.search(check['pattern'], config_content, re.IGNORECASE):
                            vuln_finding = VulnerabilityFinding(
                                id=f"flask_config_{hash(check['pattern'])}_{config_file}",
                                title=check['title'],
                                description=f"Flask configuration issue: {check['title']}",
                                severity=check['severity'],
                                category=check['category'],
                                cwe_id=check.get('cwe_id'),
                                file_path=config_path,
                                scan_type=ScanType.CONFIGURATION_SCAN
                            )
                            findings.append(vuln_finding)
        except Exception as e:
            self.logger.warning(f"Flask config check failed: {str(e)}")
    
    async def _run_env_security_check(self, target: str, findings: List[VulnerabilityFinding]) -> None:
        """Run environment variable security checks."""
        try:
            env_files = ['.env', '.env.local', '.env.production']
            
            for env_file in env_files:
                env_path = os.path.join(target, env_file)
                if os.path.exists(env_path):
                    with open(env_path, 'r') as f:
                        env_content = f.read()
                    
                    # Check for common security issues in environment files
                    if 'SECRET_KEY=' in env_content and '=' in env_content:
                        lines = env_content.split('\n')
                        for i, line in enumerate(lines):
                            if line.startswith('SECRET_KEY=') and len(line.split('=')[1]) < 32:
                                vuln_finding = VulnerabilityFinding(
                                    id=f"env_weak_secret_{env_file}",
                                    title='Weak secret key in environment file',
                                    description='Secret key appears to be too short or weak',
                                    severity=ThreatLevel.HIGH,
                                    category='cryptography',
                                    cwe_id='CWE-798',
                                    file_path=env_path,
                                    line_number=i + 1,
                                    scan_type=ScanType.CONFIGURATION_SCAN
                                )
                                findings.append(vuln_finding)
        except Exception as e:
            self.logger.warning(f"Environment security check failed: {str(e)}")
    
    async def _run_tls_config_check(self, target: str, findings: List[VulnerabilityFinding]) -> None:
        """Run TLS/SSL configuration security checks."""
        try:
            if target.startswith('https://'):
                # Check TLS configuration using SSL Labs API or similar
                async with httpx.AsyncClient() as client:
                    # Simplified TLS check - in production, use SSL Labs API
                    try:
                        response = await client.get(target, timeout=10.0)
                        
                        # Check security headers
                        headers = response.headers
                        
                        if 'strict-transport-security' not in headers:
                            vuln_finding = VulnerabilityFinding(
                                id=f"tls_missing_hsts_{hash(target)}",
                                title='Missing HSTS header',
                                description='HTTP Strict Transport Security header not found',
                                severity=ThreatLevel.MEDIUM,
                                category='transport_security',
                                cwe_id='CWE-319',
                                scan_type=ScanType.CONFIGURATION_SCAN
                            )
                            findings.append(vuln_finding)
                        
                        if 'x-frame-options' not in headers:
                            vuln_finding = VulnerabilityFinding(
                                id=f"tls_missing_xframe_{hash(target)}",
                                title='Missing X-Frame-Options header',
                                description='X-Frame-Options header not found',
                                severity=ThreatLevel.LOW,
                                category='transport_security',
                                cwe_id='CWE-1021',
                                scan_type=ScanType.CONFIGURATION_SCAN
                            )
                            findings.append(vuln_finding)
                            
                    except Exception as e:
                        self.logger.warning(f"TLS check for {target} failed: {str(e)}")
        except Exception as e:
            self.logger.warning(f"TLS configuration check failed: {str(e)}")
    
    async def _run_aws_security_hub_check(self, target: str, findings: List[VulnerabilityFinding]) -> None:
        """Run AWS Security Hub integration check."""
        try:
            # This would integrate with AWS Security Hub API
            # For now, we'll simulate some infrastructure checks
            infra_checks = [
                {
                    'title': 'S3 bucket public read access',
                    'severity': ThreatLevel.HIGH,
                    'category': 'infrastructure'
                },
                {
                    'title': 'Security group allows unrestricted access',
                    'severity': ThreatLevel.CRITICAL,
                    'category': 'infrastructure'
                }
            ]
            
            # Simulate findings (in production, query actual AWS Security Hub)
            for check in infra_checks:
                vuln_finding = VulnerabilityFinding(
                    id=f"aws_security_hub_{hash(check['title'])}",
                    title=check['title'],
                    description=f"AWS Security Hub finding: {check['title']}",
                    severity=check['severity'],
                    category=check['category'],
                    scan_type=ScanType.INFRASTRUCTURE_SCAN
                )
                findings.append(vuln_finding)
                
        except Exception as e:
            self.logger.warning(f"AWS Security Hub check failed: {str(e)}")
    
    async def _run_network_security_check(self, target: str, findings: List[VulnerabilityFinding]) -> None:
        """Run network security assessment."""
        try:
            if target.startswith('http'):
                # Basic network security checks
                import socket
                from urllib.parse import urlparse
                
                parsed_url = urlparse(target)
                hostname = parsed_url.hostname
                port = parsed_url.port or (443 if parsed_url.scheme == 'https' else 80)
                
                # Check for common open ports that shouldn't be exposed
                dangerous_ports = [22, 23, 135, 139, 445, 3389]
                
                for check_port in dangerous_ports:
                    try:
                        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                        sock.settimeout(5)
                        result = sock.connect_ex((hostname, check_port))
                        if result == 0:
                            vuln_finding = VulnerabilityFinding(
                                id=f"network_open_port_{hostname}_{check_port}",
                                title=f'Potentially dangerous port {check_port} is open',
                                description=f'Port {check_port} is accessible from external networks',
                                severity=ThreatLevel.MEDIUM,
                                category='network_security',
                                evidence=f'{hostname}:{check_port}',
                                scan_type=ScanType.INFRASTRUCTURE_SCAN
                            )
                            findings.append(vuln_finding)
                        sock.close()
                    except Exception:
                        pass
                        
        except Exception as e:
            self.logger.warning(f"Network security check failed: {str(e)}")
    
    async def _scan_patterns(self, target: str, patterns: List[Dict[str, Any]], findings: List[VulnerabilityFinding]) -> None:
        """Scan target for security patterns."""
        try:
            for root, dirs, files in os.walk(target):
                for file in files:
                    if file.endswith(('.py', '.yaml', '.yml', '.json', '.conf')):
                        file_path = os.path.join(root, file)
                        try:
                            with open(file_path, 'r', encoding='utf-8') as f:
                                content = f.read()
                                
                            for pattern_def in patterns:
                                import re
                                matches = re.finditer(pattern_def['pattern'], content, re.MULTILINE)
                                for match in matches:
                                    line_num = content[:match.start()].count('\n') + 1
                                    vuln_finding = VulnerabilityFinding(
                                        id=f"pattern_{hash(pattern_def['pattern'])}_{file_path}_{line_num}",
                                        title=pattern_def['title'],
                                        description=pattern_def.get('description', pattern_def['title']),
                                        severity=pattern_def['severity'],
                                        category=pattern_def['category'],
                                        cwe_id=pattern_def.get('cwe_id'),
                                        file_path=file_path,
                                        line_number=line_num,
                                        evidence=match.group(0),
                                        scan_type=ScanType.STATIC_ANALYSIS
                                    )
                                    findings.append(vuln_finding)
                        except Exception as e:
                            self.logger.warning(f"Failed to scan file {file_path}: {str(e)}")
        except Exception as e:
            self.logger.warning(f"Pattern scanning failed: {str(e)}")
    
    async def _run_subprocess(self, cmd: List[str], timeout: int = 300) -> Dict[str, Any]:
        """Run subprocess command asynchronously."""
        try:
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await asyncio.wait_for(
                process.communicate(), timeout=timeout
            )
            
            return {
                'returncode': process.returncode,
                'stdout': stdout.decode('utf-8'),
                'stderr': stderr.decode('utf-8')
            }
        except asyncio.TimeoutError:
            self.logger.error(f"Command timed out: {' '.join(cmd)}")
            return {
                'returncode': -1,
                'stdout': '',
                'stderr': 'Command timed out'
            }
        except Exception as e:
            self.logger.error(f"Command failed: {' '.join(cmd)} - {str(e)}")
            return {
                'returncode': -1,
                'stdout': '',
                'stderr': str(e)
            }
    
    def _convert_bandit_findings(self, bandit_result: Dict[str, Any]) -> List[VulnerabilityFinding]:
        """Convert Bandit scan results to vulnerability findings."""
        findings = []
        
        for issue in bandit_result.get('issues', []):
            vuln_finding = VulnerabilityFinding(
                id=f"bandit_{issue.get('test_id', 'unknown')}_{hash(issue.get('filename', ''))}_{issue.get('line_number', 0)}",
                title=issue.get('test_name', 'Bandit Security Issue'),
                description=issue.get('issue_text', ''),
                severity=self._map_bandit_severity(issue.get('issue_severity', 'LOW')),
                category='static_analysis',
                cwe_id=issue.get('test_id'),
                file_path=issue.get('filename'),
                line_number=issue.get('line_number'),
                evidence=issue.get('code', ''),
                references=[issue.get('more_info', '')],
                scan_type=ScanType.STATIC_ANALYSIS
            )
            findings.append(vuln_finding)
        
        return findings
    
    def _convert_safety_findings(self, safety_result: Dict[str, Any]) -> List[VulnerabilityFinding]:
        """Convert Safety scan results to vulnerability findings."""
        findings = []
        
        for vuln in safety_result.get('vulnerabilities', []):
            vuln_finding = VulnerabilityFinding(
                id=f"safety_{vuln.get('id', 'unknown')}",
                title=f"Vulnerable dependency: {vuln.get('package_name', 'unknown')}",
                description=vuln.get('advisory', ''),
                severity=self._map_safety_severity(vuln),
                category='dependency',
                evidence=f"Package: {vuln.get('package_name')} Version: {vuln.get('analyzed_version')}",
                remediation=f"Upgrade to secure version",
                references=[vuln.get('id', '')],
                scan_type=ScanType.DEPENDENCY_SCAN
            )
            findings.append(vuln_finding)
        
        return findings
    
    def _convert_zap_findings(self, zap_result: Dict[str, Any]) -> List[VulnerabilityFinding]:
        """Convert OWASP ZAP scan results to vulnerability findings."""
        findings = []
        
        alerts = zap_result.get('alerts', {}).get('alerts', [])
        for alert in alerts:
            vuln_finding = VulnerabilityFinding(
                id=f"zap_{alert.get('alertRef', 'unknown')}_{hash(alert.get('url', ''))}",
                title=alert.get('name', 'ZAP Security Alert'),
                description=alert.get('desc', ''),
                severity=self._map_zap_severity(alert.get('riskdesc', 'Low')),
                category='dynamic_analysis',
                evidence=alert.get('url', ''),
                remediation=alert.get('solution', ''),
                references=[alert.get('reference', '')],
                scan_type=ScanType.DYNAMIC_ANALYSIS
            )
            findings.append(vuln_finding)
        
        return findings
    
    def _convert_pentest_findings(self, pentest_result: Dict[str, Any]) -> List[VulnerabilityFinding]:
        """Convert penetration test results to vulnerability findings."""
        findings = []
        
        scenarios = pentest_result.get('scenarios', {})
        for scenario_name, scenario_data in scenarios.items():
            for vuln in scenario_data.get('vulnerabilities_found', []):
                vuln_finding = VulnerabilityFinding(
                    id=f"pentest_{scenario_name}_{hash(vuln.get('type', ''))}",
                    title=vuln.get('type', 'Penetration Test Finding'),
                    description=vuln.get('description', ''),
                    severity=self._map_pentest_severity(vuln.get('severity', 'medium')),
                    category='penetration_test',
                    evidence=vuln.get('endpoint', ''),
                    scan_type=ScanType.PENETRATION_TEST
                )
                findings.append(vuln_finding)
        
        return findings
    
    def _convert_compliance_findings(self, compliance_result: Dict[str, Any]) -> List[VulnerabilityFinding]:
        """Convert compliance validation results to vulnerability findings."""
        findings = []
        
        frameworks = compliance_result.get('frameworks', {})
        for framework_name, framework_data in frameworks.items():
            violations = framework_data.get('violations', [])
            for violation in violations:
                vuln_finding = VulnerabilityFinding(
                    id=f"compliance_{framework_name}_{hash(violation.get('type', ''))}",
                    title=f"Compliance violation: {violation.get('type', 'Unknown')}",
                    description=violation.get('message', ''),
                    severity=ThreatLevel.MEDIUM,
                    category='compliance',
                    scan_type=ScanType.COMPLIANCE_VALIDATION
                )
                findings.append(vuln_finding)
        
        return findings
    
    def _map_bandit_severity(self, severity: str) -> ThreatLevel:
        """Map Bandit severity to ThreatLevel enum."""
        mapping = {
            'HIGH': ThreatLevel.HIGH,
            'MEDIUM': ThreatLevel.MEDIUM,
            'LOW': ThreatLevel.LOW
        }
        return mapping.get(severity.upper(), ThreatLevel.INFO)
    
    def _map_safety_severity(self, vuln: Dict[str, Any]) -> ThreatLevel:
        """Map Safety vulnerability to severity level."""
        # Safety doesn't provide direct severity, so we use heuristics
        advisory = vuln.get('advisory', '').lower()
        
        if any(keyword in advisory for keyword in ['critical', 'remote code execution', 'arbitrary code']):
            return ThreatLevel.CRITICAL
        elif any(keyword in advisory for keyword in ['high', 'injection', 'bypass']):
            return ThreatLevel.HIGH
        elif any(keyword in advisory for keyword in ['medium', 'disclosure', 'dos']):
            return ThreatLevel.MEDIUM
        else:
            return ThreatLevel.LOW
    
    def _map_zap_severity(self, risk_desc: str) -> ThreatLevel:
        """Map OWASP ZAP risk description to ThreatLevel enum."""
        risk_desc = risk_desc.lower()
        if 'high' in risk_desc:
            return ThreatLevel.HIGH
        elif 'medium' in risk_desc:
            return ThreatLevel.MEDIUM
        elif 'low' in risk_desc:
            return ThreatLevel.LOW
        else:
            return ThreatLevel.INFO
    
    def _map_pentest_severity(self, severity: str) -> ThreatLevel:
        """Map penetration test severity to ThreatLevel enum."""
        mapping = {
            'critical': ThreatLevel.CRITICAL,
            'high': ThreatLevel.HIGH,
            'medium': ThreatLevel.MEDIUM,
            'low': ThreatLevel.LOW,
            'info': ThreatLevel.INFO
        }
        return mapping.get(severity.lower(), ThreatLevel.MEDIUM)
    
    def _map_semgrep_severity(self, severity: str) -> ThreatLevel:
        """Map Semgrep severity to ThreatLevel enum."""
        mapping = {
            'ERROR': ThreatLevel.HIGH,
            'WARNING': ThreatLevel.MEDIUM,
            'INFO': ThreatLevel.LOW
        }
        return mapping.get(severity.upper(), ThreatLevel.INFO)
    
    def _map_nuclei_severity(self, severity: str) -> ThreatLevel:
        """Map Nuclei severity to ThreatLevel enum."""
        mapping = {
            'critical': ThreatLevel.CRITICAL,
            'high': ThreatLevel.HIGH,
            'medium': ThreatLevel.MEDIUM,
            'low': ThreatLevel.LOW,
            'info': ThreatLevel.INFO
        }
        return mapping.get(severity.lower(), ThreatLevel.INFO)
    
    def _map_trivy_severity(self, severity: str) -> ThreatLevel:
        """Map Trivy severity to ThreatLevel enum."""
        mapping = {
            'CRITICAL': ThreatLevel.CRITICAL,
            'HIGH': ThreatLevel.HIGH,
            'MEDIUM': ThreatLevel.MEDIUM,
            'LOW': ThreatLevel.LOW,
            'UNKNOWN': ThreatLevel.INFO
        }
        return mapping.get(severity.upper(), ThreatLevel.INFO)
    
    def _map_pip_audit_severity(self, fix_versions: List[str]) -> ThreatLevel:
        """Map pip-audit findings to severity based on fix availability."""
        if not fix_versions:
            return ThreatLevel.HIGH  # No fix available
        else:
            return ThreatLevel.MEDIUM  # Fix available
    
    def _create_error_result(
        self,
        scan_type: ScanType,
        target: str,
        error_message: str,
        scan_id: str = None,
        start_time: datetime = None
    ) -> ScanResult:
        """Create error scan result for failed scans."""
        return ScanResult(
            scan_id=scan_id or f"{scan_type.value}_error_{int(time.time())}",
            scan_type=scan_type,
            target=target,
            start_time=start_time or datetime.utcnow(),
            end_time=datetime.utcnow(),
            status="failed",
            errors=[error_message]
        )
    
    def generate_security_report(self, output_format: str = 'json') -> str:
        """
        Generate comprehensive security report.
        
        Args:
            output_format: Output format ('json', 'html', 'pdf')
            
        Returns:
            str: Generated report content or file path
        """
        summary = self.vulnerability_db.get_scan_summary()
        active_findings = self.vulnerability_db.get_active_findings()
        
        report_data = {
            'scan_summary': summary,
            'findings': [f.to_dict() for f in active_findings],
            'report_generated_at': datetime.utcnow().isoformat(),
            'scan_results': {k: v.to_dict() for k, v in self.vulnerability_db.scan_results.items()}
        }
        
        if output_format == 'json':
            return json.dumps(report_data, indent=2)
        elif output_format == 'html':
            return self._generate_html_report(report_data)
        elif output_format == 'pdf':
            return self._generate_pdf_report(report_data)
        else:
            raise ValueError(f"Unsupported output format: {output_format}")
    
    def _generate_html_report(self, report_data: Dict[str, Any]) -> str:
        """Generate HTML security report."""
        html_template = """
        <!DOCTYPE html>
        <html>
        <head>
            <title>Security Vulnerability Report</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 40px; }
                .header { background-color: #f8f9fa; padding: 20px; border-radius: 5px; }
                .summary { margin: 20px 0; }
                .finding { border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }
                .critical { border-left: 5px solid #dc3545; }
                .high { border-left: 5px solid #fd7e14; }
                .medium { border-left: 5px solid #ffc107; }
                .low { border-left: 5px solid #28a745; }
                .info { border-left: 5px solid #17a2b8; }
                .severity { font-weight: bold; padding: 2px 8px; border-radius: 3px; color: white; }
                .severity.critical { background-color: #dc3545; }
                .severity.high { background-color: #fd7e14; }
                .severity.medium { background-color: #ffc107; color: black; }
                .severity.low { background-color: #28a745; }
                .severity.info { background-color: #17a2b8; }
            </style>
        </head>
        <body>
            <div class="header">
                <h1>Security Vulnerability Report</h1>
                <p>Generated: {generated_at}</p>
            </div>
            
            <div class="summary">
                <h2>Executive Summary</h2>
                <p><strong>Total Findings:</strong> {total_findings}</p>
                <p><strong>Risk Score:</strong> {risk_score}/100</p>
                <p><strong>Critical:</strong> {critical_count} | <strong>High:</strong> {high_count} | 
                   <strong>Medium:</strong> {medium_count} | <strong>Low:</strong> {low_count}</p>
            </div>
            
            <div class="findings">
                <h2>Vulnerability Findings</h2>
                {findings_html}
            </div>
        </body>
        </html>
        """
        
        # Generate findings HTML
        findings_html = ""
        for finding_data in report_data['findings']:
            severity = finding_data['severity']
            findings_html += f"""
            <div class="finding {severity}">
                <h3>{finding_data['title']} <span class="severity {severity}">{severity.upper()}</span></h3>
                <p><strong>Description:</strong> {finding_data['description']}</p>
                <p><strong>Category:</strong> {finding_data['category']}</p>
                {f"<p><strong>File:</strong> {finding_data['file_path']}:{finding_data['line_number']}</p>" if finding_data.get('file_path') else ""}
                {f"<p><strong>CWE:</strong> {finding_data['cwe_id']}</p>" if finding_data.get('cwe_id') else ""}
                {f"<p><strong>Remediation:</strong> {finding_data['remediation']}</p>" if finding_data.get('remediation') else ""}
            </div>
            """
        
        # Fill template
        summary = report_data['scan_summary']
        severity_dist = summary['severity_distribution']
        
        return html_template.format(
            generated_at=report_data['report_generated_at'],
            total_findings=summary['total_findings'],
            risk_score=summary['risk_score'],
            critical_count=severity_dist.get('critical', 0),
            high_count=severity_dist.get('high', 0),
            medium_count=severity_dist.get('medium', 0),
            low_count=severity_dist.get('low', 0),
            findings_html=findings_html
        )
    
    def _generate_pdf_report(self, report_data: Dict[str, Any]) -> str:
        """Generate PDF security report."""
        # For PDF generation, you would typically use libraries like reportlab
        # For now, we'll return the file path where the PDF would be saved
        pdf_path = f"security_report_{int(time.time())}.pdf"
        
        # In a real implementation, you would:
        # 1. Use reportlab or similar to create PDF
        # 2. Add charts, tables, and formatted content
        # 3. Save to file
        
        self.logger.info(f"PDF report would be generated at: {pdf_path}")
        return pdf_path


# Fixture Integration for pytest
@pytest.fixture(scope="function")
def vulnerability_scanner():
    """
    Pytest fixture providing vulnerability scanner instance.
    
    Creates a configured vulnerability scanner for security testing
    with all scanning components initialized and ready for use.
    
    Returns:
        SecurityScanner: Configured vulnerability scanner instance
    """
    config = {
        'suppression_file': '.test_suppressions.json',
        'output_directory': 'test_security_reports'
    }
    
    scanner = SecurityScanner(config)
    
    logger.info("Vulnerability scanner fixture initialized")
    return scanner


@pytest.fixture(scope="function")
def vulnerability_database():
    """
    Pytest fixture providing vulnerability database instance.
    
    Creates an empty vulnerability database for testing
    vulnerability management and deduplication functionality.
    
    Returns:
        VulnerabilityDatabase: Empty vulnerability database instance
    """
    db = VulnerabilityDatabase()
    
    logger.info("Vulnerability database fixture initialized")
    return db


# Example usage and test helpers
def create_test_finding(
    severity: ThreatLevel = ThreatLevel.MEDIUM,
    category: str = "test",
    scan_type: ScanType = ScanType.STATIC_ANALYSIS
) -> VulnerabilityFinding:
    """Create a test vulnerability finding for testing purposes."""
    return VulnerabilityFinding(
        id=f"test_{int(time.time())}_{hash(category)}",
        title=f"Test {category} vulnerability",
        description=f"This is a test {severity.value} vulnerability",
        severity=severity,
        category=category,
        scan_type=scan_type
    )


# Export key classes and functions
__all__ = [
    'SecurityScanner',
    'VulnerabilityDatabase',
    'VulnerabilityFinding',
    'ScanResult',
    'ScanType',
    'ThreatLevel',
    'vulnerability_scanner',
    'vulnerability_database',
    'create_test_finding'
]
"""
Custom Vulnerability Scanning Framework

This module implements a comprehensive vulnerability scanning framework for the Flask application
migration from Node.js, providing automated threat detection, enterprise security validation,
and security monitoring integration per Section 6.4.5 and Section 6.4.6.

Key Features:
- Custom vulnerability scanning for application-specific threats per Section 6.4.5
- Comprehensive security assessment with automated reporting per Section 6.4.5
- Enterprise security validation for compliance requirements per Section 6.4.6
- Security monitoring integration for threat visibility per Section 6.4.5
- Automated security posture validation per Section 6.4.6
- Vulnerability management workflow integration per Section 6.4.5

Security Standards Compliance:
- OWASP Top 10 vulnerability detection and validation
- SOC 2 Type II security controls assessment
- ISO 27001 security management system compliance
- NIST Cybersecurity Framework alignment
- PCI DSS security standards validation (when applicable)
- GDPR data protection and privacy compliance

Integration Components:
- Flask-Talisman security header validation per Section 6.4.1
- Auth0 JWT security testing with circuit breaker patterns per Section 6.4.2
- Rate limiting security validation using Flask-Limiter per Section 6.4.2
- Database security assessment for MongoDB and Redis per Section 6.4.3
- Cryptographic implementation validation per Section 6.4.3
- AWS KMS and encryption security testing per Section 6.4.3
- Penetration testing automation per Section 6.4.5
- Continuous security monitoring per Section 6.4.5

Architecture:
The vulnerability scanner integrates with the existing security testing infrastructure
including SecurityTestConfiguration, SecurityTestRunner, and security testing fixtures
to provide comprehensive enterprise-grade security validation capabilities.
"""

import asyncio
import json
import os
import time
import uuid
import hashlib
import tempfile
import subprocess
import concurrent.futures
from datetime import datetime, timezone, timedelta
from pathlib import Path
from typing import Dict, List, Any, Optional, Union, Tuple, Set, Callable
from dataclasses import dataclass, field, asdict
from enum import Enum
import logging
import re
import socket
import ssl
from urllib.parse import urlparse, urljoin
import warnings

# Core dependencies
import requests
import httpx
import aiohttp
import structlog
import pytest
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
import jwt
import redis
from motor import motor_asyncio
import pymongo
from flask import Flask
from flask.testing import FlaskClient

# Security scanning tools
import bandit
import safety
from safety.models import SafetyReport
import subprocess
import yaml
from prometheus_client import Counter, Histogram, Gauge, CollectorRegistry, generate_latest

# Import security testing infrastructure
from .conftest import (
    SecurityTestConfig, SecurityMonitor, AttackSimulator,
    TalismanValidator, Auth0SecurityMock, RateLimiterAttackSimulator,
    OWASPAttackPayloads, SecurityMetricsCollector, SecurityTestDataFactory,
    security_logger, SECURITY_TEST_TIMEOUT, PENETRATION_TEST_ITERATIONS
)
from .security_config import (
    SecurityTestConfiguration, SecurityTestRunner, SecurityTestResult,
    SecurityTestSeverity, AttackType, ComplianceFramework,
    security_config, security_metrics
)

# Configure structured logging for vulnerability scanning
scanner_logger = structlog.get_logger("security.vulnerability_scanner")

# Custom Prometheus metrics for vulnerability scanning
vulnerability_metrics = {
    'vulnerability_scans_executed': Counter(
        'vulnerability_scans_executed_total',
        'Total vulnerability scans executed',
        ['scan_type', 'target_type', 'severity']
    ),
    'vulnerabilities_discovered': Counter(
        'vulnerabilities_discovered_total',
        'Total vulnerabilities discovered',
        ['vulnerability_type', 'severity', 'source']
    ),
    'scan_duration_seconds': Histogram(
        'vulnerability_scan_duration_seconds',
        'Duration of vulnerability scans',
        ['scan_type', 'target_type']
    ),
    'false_positive_rate': Gauge(
        'vulnerability_false_positive_rate',
        'Rate of false positive vulnerability findings',
        ['scan_type', 'vulnerability_type']
    ),
    'security_posture_score': Gauge(
        'security_posture_score',
        'Overall security posture score',
        ['framework', 'component']
    ),
    'compliance_validation_results': Counter(
        'compliance_validation_results_total',
        'Compliance validation results',
        ['framework', 'requirement', 'status']
    ),
    'threat_detection_accuracy': Gauge(
        'threat_detection_accuracy',
        'Accuracy of threat detection algorithms',
        ['detection_type', 'algorithm']
    )
}


class VulnerabilityType(Enum):
    """Vulnerability classification types for comprehensive categorization."""
    # OWASP Top 10 Categories
    BROKEN_ACCESS_CONTROL = "broken_access_control"
    CRYPTOGRAPHIC_FAILURES = "cryptographic_failures"
    INJECTION = "injection"
    INSECURE_DESIGN = "insecure_design"
    SECURITY_MISCONFIGURATION = "security_misconfiguration"
    VULNERABLE_COMPONENTS = "vulnerable_components"
    AUTHENTICATION_FAILURES = "authentication_failures"
    DATA_INTEGRITY_FAILURES = "data_integrity_failures"
    LOGGING_MONITORING_FAILURES = "logging_monitoring_failures"
    SERVER_SIDE_REQUEST_FORGERY = "ssrf"
    
    # Additional Vulnerability Categories
    CROSS_SITE_SCRIPTING = "xss"
    SQL_INJECTION = "sql_injection"
    COMMAND_INJECTION = "command_injection"
    PATH_TRAVERSAL = "path_traversal"
    XML_EXTERNAL_ENTITY = "xxe"
    CROSS_SITE_REQUEST_FORGERY = "csrf"
    SESSION_MANAGEMENT = "session_management"
    INFORMATION_DISCLOSURE = "information_disclosure"
    BUSINESS_LOGIC = "business_logic"
    DENIAL_OF_SERVICE = "dos"
    
    # Infrastructure Vulnerabilities
    NETWORK_SECURITY = "network_security"
    CONTAINER_SECURITY = "container_security"
    CLOUD_SECURITY = "cloud_security"
    API_SECURITY = "api_security"
    MOBILE_SECURITY = "mobile_security"
    
    # Flask-Specific Vulnerabilities
    FLASK_SECURITY_HEADERS = "flask_security_headers"
    FLASK_SESSION_SECURITY = "flask_session_security"
    FLASK_TEMPLATE_INJECTION = "flask_template_injection"
    FLASK_DEBUG_MODE = "flask_debug_mode"
    
    # Auth0 and JWT Vulnerabilities
    JWT_SECURITY = "jwt_security"
    AUTH0_MISCONFIGURATION = "auth0_misconfiguration"
    OAUTH_VULNERABILITIES = "oauth_vulnerabilities"
    
    # Database and Cache Vulnerabilities
    MONGODB_SECURITY = "mongodb_security"
    REDIS_SECURITY = "redis_security"
    DATABASE_INJECTION = "database_injection"
    
    # AWS and Cloud Vulnerabilities
    AWS_IAM_MISCONFIGURATION = "aws_iam_misconfiguration"
    AWS_S3_SECURITY = "aws_s3_security"
    AWS_KMS_SECURITY = "aws_kms_security"


class ScanningTechnique(Enum):
    """Vulnerability scanning techniques for comprehensive coverage."""
    STATIC_ANALYSIS = "static_analysis"
    DYNAMIC_ANALYSIS = "dynamic_analysis"
    INTERACTIVE_ANALYSIS = "interactive_analysis"
    DEPENDENCY_SCANNING = "dependency_scanning"
    CONFIGURATION_SCANNING = "configuration_scanning"
    PENETRATION_TESTING = "penetration_testing"
    FUZZING = "fuzzing"
    BEHAVIORAL_ANALYSIS = "behavioral_analysis"
    THREAT_MODELING = "threat_modeling"
    CODE_REVIEW = "code_review"


class ThreatLevel(Enum):
    """Threat level classification for risk assessment."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFORMATIONAL = "informational"
    FALSE_POSITIVE = "false_positive"


@dataclass
class VulnerabilityFinding:
    """Comprehensive vulnerability finding data structure."""
    finding_id: str
    vulnerability_type: VulnerabilityType
    title: str
    description: str
    severity: SecurityTestSeverity
    threat_level: ThreatLevel
    confidence: float  # 0.0 to 1.0
    cvss_score: Optional[float] = None
    cve_ids: List[str] = field(default_factory=list)
    cwe_ids: List[str] = field(default_factory=list)
    
    # Location and context
    file_path: Optional[str] = None
    line_number: Optional[int] = None
    function_name: Optional[str] = None
    code_snippet: Optional[str] = None
    url_endpoint: Optional[str] = None
    http_method: Optional[str] = None
    
    # Detection details
    scanning_technique: ScanningTechnique
    detection_algorithm: str
    scan_timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    
    # Impact and exploitability
    impact_description: str = ""
    exploitability_score: Optional[float] = None
    attack_complexity: str = "unknown"
    attack_vector: str = "unknown"
    
    # Remediation
    remediation_guidance: str = ""
    remediation_complexity: str = "unknown"
    remediation_priority: int = 1  # 1 (highest) to 5 (lowest)
    
    # Compliance and standards
    affected_compliance_frameworks: List[ComplianceFramework] = field(default_factory=list)
    owasp_category: Optional[str] = None
    sans_category: Optional[str] = None
    
    # Evidence and proof of concept
    evidence: List[Dict[str, Any]] = field(default_factory=list)
    proof_of_concept: Optional[str] = None
    reproduction_steps: List[str] = field(default_factory=list)
    
    # Metadata
    tags: List[str] = field(default_factory=list)
    references: List[str] = field(default_factory=list)
    false_positive_likelihood: float = 0.0
    custom_fields: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ScanConfiguration:
    """Vulnerability scan configuration with comprehensive options."""
    scan_id: str
    scan_name: str
    target_type: str  # "application", "api", "infrastructure", "dependencies"
    target_url: Optional[str] = None
    target_path: Optional[str] = None
    
    # Scanning scope and techniques
    enabled_techniques: List[ScanningTechnique] = field(default_factory=list)
    vulnerability_types: List[VulnerabilityType] = field(default_factory=list)
    compliance_frameworks: List[ComplianceFramework] = field(default_factory=list)
    
    # Scanning parameters
    max_scan_duration: int = 3600  # seconds
    max_concurrent_scans: int = 5
    rate_limit_delay: float = 1.0
    timeout_per_request: int = 30
    
    # Authentication and authorization
    authentication_config: Dict[str, Any] = field(default_factory=dict)
    authorization_headers: Dict[str, str] = field(default_factory=dict)
    
    # Filtering and exclusions
    exclude_paths: List[str] = field(default_factory=list)
    exclude_file_patterns: List[str] = field(default_factory=list)
    include_only_paths: List[str] = field(default_factory=list)
    
    # Reporting and output
    output_formats: List[str] = field(default_factory=lambda: ["json", "html"])
    detailed_reporting: bool = True
    include_false_positives: bool = False
    
    # Integration settings
    webhook_urls: List[str] = field(default_factory=list)
    notification_channels: List[str] = field(default_factory=list)
    integration_configs: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ScanResult:
    """Comprehensive vulnerability scan result."""
    scan_id: str
    scan_configuration: ScanConfiguration
    start_time: datetime
    end_time: datetime
    scan_duration: float
    
    # Findings and results
    findings: List[VulnerabilityFinding] = field(default_factory=list)
    total_vulnerabilities: int = 0
    vulnerabilities_by_severity: Dict[str, int] = field(default_factory=dict)
    vulnerabilities_by_type: Dict[str, int] = field(default_factory=dict)
    
    # Scan execution details
    scanned_targets: List[str] = field(default_factory=list)
    successful_scans: int = 0
    failed_scans: int = 0
    scan_errors: List[str] = field(default_factory=list)
    
    # Quality metrics
    false_positive_count: int = 0
    confidence_distribution: Dict[str, int] = field(default_factory=dict)
    coverage_metrics: Dict[str, float] = field(default_factory=dict)
    
    # Compliance assessment
    compliance_results: Dict[ComplianceFramework, Dict[str, Any]] = field(default_factory=dict)
    security_posture_score: float = 0.0
    risk_score: float = 0.0
    
    # Remediation and recommendations
    remediation_summary: Dict[str, Any] = field(default_factory=dict)
    priority_findings: List[VulnerabilityFinding] = field(default_factory=list)
    recommended_actions: List[str] = field(default_factory=list)
    
    # Metadata and tracking
    scan_version: str = "1.0.0"
    scanner_version: str = "1.0.0"
    metadata: Dict[str, Any] = field(default_factory=dict)


class VulnerabilityDatabase:
    """
    Vulnerability knowledge base and signature database for comprehensive threat detection.
    
    Implements custom vulnerability signatures, threat intelligence integration,
    and enterprise security rule management per Section 6.4.5.
    """
    
    def __init__(self):
        self.logger = scanner_logger.bind(component="vulnerability_database")
        self.signatures: Dict[str, Dict[str, Any]] = {}
        self.threat_intelligence: Dict[str, Any] = {}
        self.custom_rules: List[Dict[str, Any]] = []
        
        # Initialize vulnerability signatures
        self._initialize_vulnerability_signatures()
        self._load_threat_intelligence()
        self._setup_custom_rules()
        
    def _initialize_vulnerability_signatures(self):
        """Initialize comprehensive vulnerability detection signatures."""
        self.signatures = {
            # Flask-Specific Vulnerabilities
            "flask_debug_mode": {
                "pattern": r"debug\s*=\s*True|FLASK_DEBUG\s*=\s*['\"]?1['\"]?|app\.debug\s*=\s*True",
                "vulnerability_type": VulnerabilityType.SECURITY_MISCONFIGURATION,
                "severity": SecurityTestSeverity.HIGH,
                "description": "Flask debug mode enabled in production",
                "remediation": "Disable debug mode in production environments"
            },
            
            "flask_secret_key_weak": {
                "pattern": r"SECRET_KEY\s*=\s*['\"](?:secret|default|test|dev|password)['\"]",
                "vulnerability_type": VulnerabilityType.CRYPTOGRAPHIC_FAILURES,
                "severity": SecurityTestSeverity.CRITICAL,
                "description": "Weak or default Flask SECRET_KEY detected",
                "remediation": "Use cryptographically strong, randomly generated SECRET_KEY"
            },
            
            "flask_template_injection": {
                "pattern": r"\{\{\s*.*?request\..*?\}\}|\{\{\s*.*?config\..*?\}\}",
                "vulnerability_type": VulnerabilityType.FLASK_TEMPLATE_INJECTION,
                "severity": SecurityTestSeverity.HIGH,
                "description": "Potential Flask template injection vulnerability",
                "remediation": "Sanitize user input and avoid direct template rendering"
            },
            
            # JWT and Authentication Vulnerabilities
            "jwt_none_algorithm": {
                "pattern": r'algorithm\s*[:=]\s*[\'"]none[\'"]|alg\s*[:=]\s*[\'"]none[\'"]',
                "vulnerability_type": VulnerabilityType.JWT_SECURITY,
                "severity": SecurityTestSeverity.CRITICAL,
                "description": "JWT 'none' algorithm vulnerability detected",
                "remediation": "Use strong cryptographic algorithms (RS256, ES256) for JWT signing"
            },
            
            "jwt_weak_secret": {
                "pattern": r'jwt_secret\s*[:=]\s*[\'"](?:secret|test|dev|password)[\'"]',
                "vulnerability_type": VulnerabilityType.AUTHENTICATION_FAILURES,
                "severity": SecurityTestSeverity.HIGH,
                "description": "Weak JWT secret key detected",
                "remediation": "Use cryptographically strong, randomly generated JWT secrets"
            },
            
            # SQL Injection Patterns
            "sql_injection_basic": {
                "pattern": r"SELECT\s+.*?FROM\s+.*?WHERE\s+.*?['\"]?\s*\+|execute\s*\(\s*['\"].*?['\"].*?\+",
                "vulnerability_type": VulnerabilityType.SQL_INJECTION,
                "severity": SecurityTestSeverity.CRITICAL,
                "description": "Potential SQL injection vulnerability through string concatenation",
                "remediation": "Use parameterized queries and input validation"
            },
            
            # XSS Vulnerabilities
            "xss_reflected": {
                "pattern": r"render_template_string\s*\(\s*.*?request\.|flash\s*\(\s*.*?request\.",
                "vulnerability_type": VulnerabilityType.CROSS_SITE_SCRIPTING,
                "severity": SecurityTestSeverity.HIGH,
                "description": "Potential reflected XSS through unsanitized user input",
                "remediation": "Sanitize user input and use proper template escaping"
            },
            
            # MongoDB Injection
            "mongodb_injection": {
                "pattern": r"db\..*?\.find\s*\(\s*request\.|collection\.find\s*\(\s*\{.*?request\.",
                "vulnerability_type": VulnerabilityType.DATABASE_INJECTION,
                "severity": SecurityTestSeverity.HIGH,
                "description": "Potential MongoDB injection through unsanitized input",
                "remediation": "Validate and sanitize input before database queries"
            },
            
            # Cryptographic Issues
            "weak_crypto_algorithm": {
                "pattern": r"MD5|SHA1(?!.*SHA256)|DES(?!.*AES)|RC4",
                "vulnerability_type": VulnerabilityType.CRYPTOGRAPHIC_FAILURES,
                "severity": SecurityTestSeverity.MEDIUM,
                "description": "Weak cryptographic algorithm detected",
                "remediation": "Use strong cryptographic algorithms (AES-256, SHA-256, RSA-2048+)"
            },
            
            # Information Disclosure
            "debug_information_disclosure": {
                "pattern": r"traceback\.print_exc|print\s*\(\s*e\s*\)|logger\.exception\s*\(\s*.*?e\s*\)",
                "vulnerability_type": VulnerabilityType.INFORMATION_DISCLOSURE,
                "severity": SecurityTestSeverity.MEDIUM,
                "description": "Potential information disclosure through error messages",
                "remediation": "Implement proper error handling without exposing sensitive information"
            },
            
            # Hardcoded Credentials
            "hardcoded_credentials": {
                "pattern": r"password\s*[:=]\s*['\"][^'\"]*['\"]|api_key\s*[:=]\s*['\"][^'\"]*['\"]",
                "vulnerability_type": VulnerabilityType.CRYPTOGRAPHIC_FAILURES,
                "severity": SecurityTestSeverity.HIGH,
                "description": "Hardcoded credentials detected in source code",
                "remediation": "Use environment variables or secure credential management"
            },
            
            # Command Injection
            "command_injection": {
                "pattern": r"os\.system\s*\(|subprocess\.call\s*\(.*?shell\s*=\s*True|eval\s*\(",
                "vulnerability_type": VulnerabilityType.COMMAND_INJECTION,
                "severity": SecurityTestSeverity.CRITICAL,
                "description": "Potential command injection vulnerability",
                "remediation": "Avoid dynamic command execution and validate input"
            },
            
            # Path Traversal
            "path_traversal": {
                "pattern": r"open\s*\(\s*.*?request\.|file\s*\(\s*.*?request\.|os\.path\.join\s*\(\s*.*?request\.",
                "vulnerability_type": VulnerabilityType.PATH_TRAVERSAL,
                "severity": SecurityTestSeverity.HIGH,
                "description": "Potential path traversal vulnerability",
                "remediation": "Validate and sanitize file paths, use allowlists"
            }
        }
        
        self.logger.info(f"Initialized {len(self.signatures)} vulnerability signatures")
    
    def _load_threat_intelligence(self):
        """Load threat intelligence data for enhanced detection."""
        self.threat_intelligence = {
            "malicious_ips": [
                "127.0.0.1",  # Placeholder for actual threat intelligence
                "0.0.0.0"
            ],
            "suspicious_user_agents": [
                "sqlmap",
                "nikto",
                "nmap",
                "burp",
                "owasp zap"
            ],
            "known_attack_patterns": [
                "' OR '1'='1",
                "<script>alert(",
                "../etc/passwd",
                "${jndi:ldap:",
                "{{7*7}}"
            ],
            "malicious_file_hashes": [],
            "exploit_signatures": []
        }
        
        self.logger.info("Loaded threat intelligence data")
    
    def _setup_custom_rules(self):
        """Setup custom vulnerability detection rules."""
        self.custom_rules = [
            {
                "rule_id": "flask_talisman_missing",
                "description": "Flask-Talisman security headers not implemented",
                "check_function": self._check_flask_talisman_implementation,
                "severity": SecurityTestSeverity.MEDIUM,
                "vulnerability_type": VulnerabilityType.FLASK_SECURITY_HEADERS
            },
            {
                "rule_id": "auth0_misconfiguration",
                "description": "Auth0 configuration security issues",
                "check_function": self._check_auth0_configuration,
                "severity": SecurityTestSeverity.HIGH,
                "vulnerability_type": VulnerabilityType.AUTH0_MISCONFIGURATION
            },
            {
                "rule_id": "redis_security_config",
                "description": "Redis security configuration issues",
                "check_function": self._check_redis_security,
                "severity": SecurityTestSeverity.MEDIUM,
                "vulnerability_type": VulnerabilityType.REDIS_SECURITY
            },
            {
                "rule_id": "mongodb_security_config",
                "description": "MongoDB security configuration issues",
                "check_function": self._check_mongodb_security,
                "severity": SecurityTestSeverity.MEDIUM,
                "vulnerability_type": VulnerabilityType.MONGODB_SECURITY
            }
        ]
        
        self.logger.info(f"Setup {len(self.custom_rules)} custom security rules")
    
    def _check_flask_talisman_implementation(self, target_context: Dict[str, Any]) -> List[VulnerabilityFinding]:
        """Check Flask-Talisman security headers implementation."""
        findings = []
        
        # Check if Flask-Talisman is imported and configured
        source_files = target_context.get("source_files", [])
        talisman_found = False
        
        for file_path, content in source_files:
            if "flask_talisman" in content.lower() or "talisman" in content.lower():
                talisman_found = True
                break
        
        if not talisman_found:
            finding = VulnerabilityFinding(
                finding_id=f"flask_talisman_missing_{uuid.uuid4().hex[:8]}",
                vulnerability_type=VulnerabilityType.FLASK_SECURITY_HEADERS,
                title="Flask-Talisman Security Headers Missing",
                description="Flask-Talisman security headers middleware not implemented",
                severity=SecurityTestSeverity.MEDIUM,
                threat_level=ThreatLevel.MEDIUM,
                confidence=0.9,
                scanning_technique=ScanningTechnique.STATIC_ANALYSIS,
                detection_algorithm="flask_talisman_checker",
                remediation_guidance="Implement Flask-Talisman for comprehensive security headers",
                affected_compliance_frameworks=[ComplianceFramework.OWASP_TOP10],
                owasp_category="A05:2021 – Security Misconfiguration"
            )
            findings.append(finding)
        
        return findings
    
    def _check_auth0_configuration(self, target_context: Dict[str, Any]) -> List[VulnerabilityFinding]:
        """Check Auth0 configuration for security issues."""
        findings = []
        
        # Check for hardcoded Auth0 secrets
        source_files = target_context.get("source_files", [])
        
        for file_path, content in source_files:
            if re.search(r"auth0.*client_secret\s*=\s*['\"][^'\"]*['\"]", content, re.IGNORECASE):
                finding = VulnerabilityFinding(
                    finding_id=f"auth0_hardcoded_secret_{uuid.uuid4().hex[:8]}",
                    vulnerability_type=VulnerabilityType.AUTH0_MISCONFIGURATION,
                    title="Hardcoded Auth0 Client Secret",
                    description="Auth0 client secret hardcoded in source code",
                    severity=SecurityTestSeverity.HIGH,
                    threat_level=ThreatLevel.HIGH,
                    confidence=0.95,
                    file_path=file_path,
                    scanning_technique=ScanningTechnique.STATIC_ANALYSIS,
                    detection_algorithm="auth0_config_checker",
                    remediation_guidance="Use environment variables for Auth0 client secrets",
                    affected_compliance_frameworks=[ComplianceFramework.SOC2_TYPE2],
                    cwe_ids=["CWE-798"]
                )
                findings.append(finding)
        
        return findings
    
    def _check_redis_security(self, target_context: Dict[str, Any]) -> List[VulnerabilityFinding]:
        """Check Redis security configuration."""
        findings = []
        
        # Check for Redis password configuration
        redis_config = target_context.get("redis_config", {})
        
        if not redis_config.get("password"):
            finding = VulnerabilityFinding(
                finding_id=f"redis_no_auth_{uuid.uuid4().hex[:8]}",
                vulnerability_type=VulnerabilityType.REDIS_SECURITY,
                title="Redis Authentication Not Configured",
                description="Redis instance configured without authentication",
                severity=SecurityTestSeverity.MEDIUM,
                threat_level=ThreatLevel.MEDIUM,
                confidence=0.8,
                scanning_technique=ScanningTechnique.CONFIGURATION_SCANNING,
                detection_algorithm="redis_security_checker",
                remediation_guidance="Configure Redis with strong authentication and encryption",
                affected_compliance_frameworks=[ComplianceFramework.SOC2_TYPE2],
                cwe_ids=["CWE-306"]
            )
            findings.append(finding)
        
        return findings
    
    def _check_mongodb_security(self, target_context: Dict[str, Any]) -> List[VulnerabilityFinding]:
        """Check MongoDB security configuration."""
        findings = []
        
        # Check for MongoDB authentication and encryption
        mongo_config = target_context.get("mongodb_config", {})
        
        if not mongo_config.get("ssl", False):
            finding = VulnerabilityFinding(
                finding_id=f"mongodb_no_ssl_{uuid.uuid4().hex[:8]}",
                vulnerability_type=VulnerabilityType.MONGODB_SECURITY,
                title="MongoDB SSL/TLS Not Enabled",
                description="MongoDB connection not using SSL/TLS encryption",
                severity=SecurityTestSeverity.MEDIUM,
                threat_level=ThreatLevel.MEDIUM,
                confidence=0.9,
                scanning_technique=ScanningTechnique.CONFIGURATION_SCANNING,
                detection_algorithm="mongodb_security_checker",
                remediation_guidance="Enable SSL/TLS encryption for MongoDB connections",
                affected_compliance_frameworks=[ComplianceFramework.SOC2_TYPE2],
                cwe_ids=["CWE-319"]
            )
            findings.append(finding)
        
        return findings
    
    def search_vulnerabilities(self, content: str, file_path: str = "") -> List[VulnerabilityFinding]:
        """Search for vulnerabilities using signature database."""
        findings = []
        
        for signature_id, signature in self.signatures.items():
            pattern = signature["pattern"]
            matches = re.finditer(pattern, content, re.IGNORECASE | re.MULTILINE)
            
            for match in matches:
                line_number = content[:match.start()].count('\n') + 1
                
                finding = VulnerabilityFinding(
                    finding_id=f"{signature_id}_{uuid.uuid4().hex[:8]}",
                    vulnerability_type=signature["vulnerability_type"],
                    title=signature["description"],
                    description=signature["description"],
                    severity=signature["severity"],
                    threat_level=ThreatLevel.HIGH if signature["severity"] == SecurityTestSeverity.CRITICAL else ThreatLevel.MEDIUM,
                    confidence=0.8,  # Default confidence for signature-based detection
                    file_path=file_path,
                    line_number=line_number,
                    code_snippet=match.group(0),
                    scanning_technique=ScanningTechnique.STATIC_ANALYSIS,
                    detection_algorithm=f"signature_{signature_id}",
                    remediation_guidance=signature["remediation"],
                    affected_compliance_frameworks=[ComplianceFramework.OWASP_TOP10]
                )
                findings.append(finding)
        
        return findings
    
    def check_threat_intelligence(self, indicators: Dict[str, Any]) -> List[VulnerabilityFinding]:
        """Check indicators against threat intelligence database."""
        findings = []
        
        # Check for malicious IPs
        if "source_ip" in indicators:
            source_ip = indicators["source_ip"]
            if source_ip in self.threat_intelligence["malicious_ips"]:
                finding = VulnerabilityFinding(
                    finding_id=f"malicious_ip_{uuid.uuid4().hex[:8]}",
                    vulnerability_type=VulnerabilityType.NETWORK_SECURITY,
                    title="Malicious IP Address Detected",
                    description=f"Traffic from known malicious IP address: {source_ip}",
                    severity=SecurityTestSeverity.HIGH,
                    threat_level=ThreatLevel.HIGH,
                    confidence=0.95,
                    scanning_technique=ScanningTechnique.BEHAVIORAL_ANALYSIS,
                    detection_algorithm="threat_intelligence_matcher",
                    remediation_guidance="Block malicious IP address and investigate potential compromise"
                )
                findings.append(finding)
        
        # Check for suspicious user agents
        if "user_agent" in indicators:
            user_agent = indicators["user_agent"].lower()
            for suspicious_ua in self.threat_intelligence["suspicious_user_agents"]:
                if suspicious_ua in user_agent:
                    finding = VulnerabilityFinding(
                        finding_id=f"suspicious_ua_{uuid.uuid4().hex[:8]}",
                        vulnerability_type=VulnerabilityType.NETWORK_SECURITY,
                        title="Suspicious User Agent Detected",
                        description=f"Request with suspicious user agent: {indicators['user_agent']}",
                        severity=SecurityTestSeverity.MEDIUM,
                        threat_level=ThreatLevel.MEDIUM,
                        confidence=0.7,
                        scanning_technique=ScanningTechnique.BEHAVIORAL_ANALYSIS,
                        detection_algorithm="user_agent_analysis",
                        remediation_guidance="Monitor and potentially block scanning tools"
                    )
                    findings.append(finding)
                    break
        
        return findings


class StaticAnalysisScanner:
    """
    Static analysis vulnerability scanner for comprehensive code security assessment.
    
    Implements advanced static analysis techniques including AST parsing,
    control flow analysis, and security pattern detection per Section 6.4.5.
    """
    
    def __init__(self, vulnerability_db: VulnerabilityDatabase):
        self.logger = scanner_logger.bind(component="static_analysis_scanner")
        self.vulnerability_db = vulnerability_db
        self.supported_extensions = ['.py', '.js', '.ts', '.html', '.yml', '.yaml', '.json']
        
    async def scan_codebase(self, target_path: str, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Perform comprehensive static analysis of codebase."""
        findings = []
        scan_start = time.time()
        
        try:
            # Discover source files
            source_files = self._discover_source_files(target_path, config)
            self.logger.info(f"Discovered {len(source_files)} source files for analysis")
            
            # Analyze files with concurrency control
            semaphore = asyncio.Semaphore(config.max_concurrent_scans)
            
            async def analyze_file(file_path: str) -> List[VulnerabilityFinding]:
                async with semaphore:
                    return await self._analyze_source_file(file_path, config)
            
            # Execute analysis tasks
            analysis_tasks = [analyze_file(file_path) for file_path in source_files]
            analysis_results = await asyncio.gather(*analysis_tasks, return_exceptions=True)
            
            # Collect findings
            for result in analysis_results:
                if isinstance(result, Exception):
                    self.logger.error(f"Analysis error: {result}")
                    continue
                findings.extend(result)
            
            # Perform additional security checks
            additional_findings = await self._perform_security_checks(target_path, config)
            findings.extend(additional_findings)
            
            # Record metrics
            scan_duration = time.time() - scan_start
            vulnerability_metrics['scan_duration_seconds'].labels(
                scan_type='static_analysis',
                target_type=config.target_type
            ).observe(scan_duration)
            
            self.logger.info(f"Static analysis completed in {scan_duration:.2f}s with {len(findings)} findings")
            return findings
            
        except Exception as e:
            self.logger.error(f"Static analysis scan failed: {e}")
            raise
    
    def _discover_source_files(self, target_path: str, config: ScanConfiguration) -> List[str]:
        """Discover source files for analysis."""
        source_files = []
        target_path_obj = Path(target_path)
        
        if target_path_obj.is_file():
            if target_path_obj.suffix in self.supported_extensions:
                source_files.append(str(target_path_obj))
        else:
            for file_path in target_path_obj.rglob('*'):
                if (file_path.is_file() and 
                    file_path.suffix in self.supported_extensions and
                    not self._is_excluded_file(str(file_path), config)):
                    source_files.append(str(file_path))
        
        return source_files
    
    def _is_excluded_file(self, file_path: str, config: ScanConfiguration) -> bool:
        """Check if file should be excluded from analysis."""
        # Check exclude patterns
        for pattern in config.exclude_file_patterns:
            if re.search(pattern, file_path):
                return True
        
        # Check exclude paths
        for exclude_path in config.exclude_paths:
            if exclude_path in file_path:
                return True
        
        # Check include-only paths
        if config.include_only_paths:
            included = False
            for include_path in config.include_only_paths:
                if include_path in file_path:
                    included = True
                    break
            if not included:
                return True
        
        return False
    
    async def _analyze_source_file(self, file_path: str, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Analyze individual source file for vulnerabilities."""
        findings = []
        
        try:
            # Read file content
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            # Signature-based vulnerability detection
            signature_findings = self.vulnerability_db.search_vulnerabilities(content, file_path)
            findings.extend(signature_findings)
            
            # File-specific analysis based on extension
            file_ext = Path(file_path).suffix.lower()
            
            if file_ext == '.py':
                python_findings = await self._analyze_python_file(file_path, content, config)
                findings.extend(python_findings)
            elif file_ext in ['.js', '.ts']:
                javascript_findings = await self._analyze_javascript_file(file_path, content, config)
                findings.extend(javascript_findings)
            elif file_ext == '.html':
                html_findings = await self._analyze_html_file(file_path, content, config)
                findings.extend(html_findings)
            elif file_ext in ['.yml', '.yaml']:
                yaml_findings = await self._analyze_yaml_file(file_path, content, config)
                findings.extend(yaml_findings)
            elif file_ext == '.json':
                json_findings = await self._analyze_json_file(file_path, content, config)
                findings.extend(json_findings)
            
            return findings
            
        except Exception as e:
            self.logger.warning(f"Failed to analyze file {file_path}: {e}")
            return []
    
    async def _analyze_python_file(self, file_path: str, content: str, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Analyze Python file for security vulnerabilities."""
        findings = []
        
        try:
            # Use bandit for Python security analysis
            bandit_findings = await self._run_bandit_analysis(file_path, content)
            findings.extend(bandit_findings)
            
            # Custom Python security checks
            custom_findings = self._check_python_security_patterns(file_path, content)
            findings.extend(custom_findings)
            
        except Exception as e:
            self.logger.warning(f"Python analysis failed for {file_path}: {e}")
        
        return findings
    
    async def _run_bandit_analysis(self, file_path: str, content: str) -> List[VulnerabilityFinding]:
        """Run bandit security analysis on Python code."""
        findings = []
        
        try:
            # Create temporary file for bandit analysis
            with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as temp_file:
                temp_file.write(content)
                temp_file.flush()
                
                # Run bandit
                cmd = ['bandit', '-f', 'json', '-ll', temp_file.name]
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
                
                if result.stdout:
                    bandit_output = json.loads(result.stdout)
                    
                    for issue in bandit_output.get('results', []):
                        severity_map = {
                            'LOW': SecurityTestSeverity.LOW,
                            'MEDIUM': SecurityTestSeverity.MEDIUM,
                            'HIGH': SecurityTestSeverity.HIGH
                        }
                        
                        finding = VulnerabilityFinding(
                            finding_id=f"bandit_{uuid.uuid4().hex[:8]}",
                            vulnerability_type=VulnerabilityType.SECURITY_MISCONFIGURATION,
                            title=issue.get('test_name', 'Bandit Security Issue'),
                            description=issue.get('issue_text', 'Security issue detected by bandit'),
                            severity=severity_map.get(issue.get('issue_severity', 'MEDIUM'), SecurityTestSeverity.MEDIUM),
                            threat_level=ThreatLevel.MEDIUM,
                            confidence=float(issue.get('issue_confidence', 0.5)) / 10.0,  # Convert bandit confidence
                            file_path=file_path,
                            line_number=issue.get('line_number'),
                            code_snippet=issue.get('code', ''),
                            scanning_technique=ScanningTechnique.STATIC_ANALYSIS,
                            detection_algorithm="bandit",
                            cwe_ids=[issue.get('test_id', '').replace('B', 'CWE-')] if issue.get('test_id') else [],
                            remediation_guidance=issue.get('more_info', 'Review bandit documentation for remediation guidance')
                        )
                        findings.append(finding)
                
                # Cleanup
                os.unlink(temp_file.name)
                
        except Exception as e:
            self.logger.warning(f"Bandit analysis failed: {e}")
        
        return findings
    
    def _check_python_security_patterns(self, file_path: str, content: str) -> List[VulnerabilityFinding]:
        """Check for Python-specific security patterns."""
        findings = []
        
        # Check for Flask-specific security issues
        flask_patterns = [
            {
                "pattern": r"@app\.route\s*\([^)]*methods\s*=\s*\[[^\]]*['\"]GET['\"][^\]]*['\"]POST['\"]",
                "vulnerability_type": VulnerabilityType.SECURITY_MISCONFIGURATION,
                "title": "Flask Route Accepts Both GET and POST",
                "description": "Route accepts both GET and POST methods without explicit justification",
                "severity": SecurityTestSeverity.LOW
            },
            {
                "pattern": r"request\.args\.get\s*\([^)]*\)\s*[^,\s]*\s*(?:without|not.*validated)",
                "vulnerability_type": VulnerabilityType.INJECTION,
                "title": "Unvalidated Request Parameter",
                "description": "Request parameter accessed without validation",
                "severity": SecurityTestSeverity.MEDIUM
            }
        ]
        
        for pattern_config in flask_patterns:
            matches = re.finditer(pattern_config["pattern"], content, re.IGNORECASE | re.MULTILINE)
            for match in matches:
                line_number = content[:match.start()].count('\n') + 1
                
                finding = VulnerabilityFinding(
                    finding_id=f"python_pattern_{uuid.uuid4().hex[:8]}",
                    vulnerability_type=pattern_config["vulnerability_type"],
                    title=pattern_config["title"],
                    description=pattern_config["description"],
                    severity=pattern_config["severity"],
                    threat_level=ThreatLevel.MEDIUM,
                    confidence=0.6,
                    file_path=file_path,
                    line_number=line_number,
                    code_snippet=match.group(0),
                    scanning_technique=ScanningTechnique.STATIC_ANALYSIS,
                    detection_algorithm="python_security_patterns"
                )
                findings.append(finding)
        
        return findings
    
    async def _analyze_javascript_file(self, file_path: str, content: str, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Analyze JavaScript/TypeScript file for vulnerabilities."""
        findings = []
        
        # Check for common JavaScript security issues
        js_patterns = [
            {
                "pattern": r"eval\s*\(|Function\s*\(.*\)",
                "vulnerability_type": VulnerabilityType.INJECTION,
                "title": "Dangerous Code Execution",
                "description": "Use of eval() or Function() constructor detected",
                "severity": SecurityTestSeverity.HIGH
            },
            {
                "pattern": r"innerHTML\s*=\s*.*\+|outerHTML\s*=\s*.*\+",
                "vulnerability_type": VulnerabilityType.CROSS_SITE_SCRIPTING,
                "title": "Potential XSS via innerHTML",
                "description": "Dynamic content insertion via innerHTML without sanitization",
                "severity": SecurityTestSeverity.MEDIUM
            }
        ]
        
        for pattern_config in js_patterns:
            matches = re.finditer(pattern_config["pattern"], content, re.IGNORECASE | re.MULTILINE)
            for match in matches:
                line_number = content[:match.start()].count('\n') + 1
                
                finding = VulnerabilityFinding(
                    finding_id=f"js_pattern_{uuid.uuid4().hex[:8]}",
                    vulnerability_type=pattern_config["vulnerability_type"],
                    title=pattern_config["title"],
                    description=pattern_config["description"],
                    severity=pattern_config["severity"],
                    threat_level=ThreatLevel.MEDIUM,
                    confidence=0.7,
                    file_path=file_path,
                    line_number=line_number,
                    code_snippet=match.group(0),
                    scanning_technique=ScanningTechnique.STATIC_ANALYSIS,
                    detection_algorithm="javascript_security_patterns"
                )
                findings.append(finding)
        
        return findings
    
    async def _analyze_html_file(self, file_path: str, content: str, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Analyze HTML file for security vulnerabilities."""
        findings = []
        
        # Check for HTML security issues
        html_patterns = [
            {
                "pattern": r"<script[^>]*src\s*=\s*['\"]http://",
                "vulnerability_type": VulnerabilityType.SECURITY_MISCONFIGURATION,
                "title": "Insecure Script Source",
                "description": "Script loaded over insecure HTTP connection",
                "severity": SecurityTestSeverity.MEDIUM
            },
            {
                "pattern": r"onclick\s*=\s*['\"].*eval\s*\(",
                "vulnerability_type": VulnerabilityType.CROSS_SITE_SCRIPTING,
                "title": "JavaScript eval() in Event Handler",
                "description": "Use of eval() in HTML event handler",
                "severity": SecurityTestSeverity.HIGH
            }
        ]
        
        for pattern_config in html_patterns:
            matches = re.finditer(pattern_config["pattern"], content, re.IGNORECASE | re.MULTILINE)
            for match in matches:
                line_number = content[:match.start()].count('\n') + 1
                
                finding = VulnerabilityFinding(
                    finding_id=f"html_pattern_{uuid.uuid4().hex[:8]}",
                    vulnerability_type=pattern_config["vulnerability_type"],
                    title=pattern_config["title"],
                    description=pattern_config["description"],
                    severity=pattern_config["severity"],
                    threat_level=ThreatLevel.MEDIUM,
                    confidence=0.8,
                    file_path=file_path,
                    line_number=line_number,
                    code_snippet=match.group(0),
                    scanning_technique=ScanningTechnique.STATIC_ANALYSIS,
                    detection_algorithm="html_security_patterns"
                )
                findings.append(finding)
        
        return findings
    
    async def _analyze_yaml_file(self, file_path: str, content: str, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Analyze YAML file for security configurations."""
        findings = []
        
        try:
            # Parse YAML content
            yaml_data = yaml.safe_load(content)
            
            # Check for security misconfigurations in YAML
            if isinstance(yaml_data, dict):
                findings.extend(self._check_yaml_security_config(file_path, yaml_data))
                
        except yaml.YAMLError as e:
            self.logger.warning(f"Failed to parse YAML file {file_path}: {e}")
        
        return findings
    
    def _check_yaml_security_config(self, file_path: str, yaml_data: Dict[str, Any]) -> List[VulnerabilityFinding]:
        """Check YAML configuration for security issues."""
        findings = []
        
        # Check for hardcoded credentials in YAML
        sensitive_keys = ['password', 'secret', 'key', 'token', 'api_key']
        
        def check_dict_recursively(data: Dict[str, Any], path: str = ""):
            for key, value in data.items():
                current_path = f"{path}.{key}" if path else key
                
                if isinstance(value, dict):
                    check_dict_recursively(value, current_path)
                elif isinstance(value, str) and any(sensitive_key in key.lower() for sensitive_key in sensitive_keys):
                    if value and not value.startswith('${') and not value.startswith('ENV:'):
                        finding = VulnerabilityFinding(
                            finding_id=f"yaml_hardcoded_secret_{uuid.uuid4().hex[:8]}",
                            vulnerability_type=VulnerabilityType.CRYPTOGRAPHIC_FAILURES,
                            title="Hardcoded Secret in YAML",
                            description=f"Potential hardcoded secret in YAML configuration: {current_path}",
                            severity=SecurityTestSeverity.MEDIUM,
                            threat_level=ThreatLevel.MEDIUM,
                            confidence=0.7,
                            file_path=file_path,
                            scanning_technique=ScanningTechnique.CONFIGURATION_SCANNING,
                            detection_algorithm="yaml_secret_detector",
                            remediation_guidance="Use environment variables or secure configuration management"
                        )
                        findings.append(finding)
        
        check_dict_recursively(yaml_data)
        return findings
    
    async def _analyze_json_file(self, file_path: str, content: str, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Analyze JSON file for security configurations."""
        findings = []
        
        try:
            # Parse JSON content
            json_data = json.loads(content)
            
            # Check for security issues in JSON
            if isinstance(json_data, dict):
                findings.extend(self._check_json_security_config(file_path, json_data))
                
        except json.JSONDecodeError as e:
            self.logger.warning(f"Failed to parse JSON file {file_path}: {e}")
        
        return findings
    
    def _check_json_security_config(self, file_path: str, json_data: Dict[str, Any]) -> List[VulnerabilityFinding]:
        """Check JSON configuration for security issues."""
        findings = []
        
        # Check for package.json security issues
        if 'dependencies' in json_data or 'devDependencies' in json_data:
            findings.extend(self._check_package_json_security(file_path, json_data))
        
        return findings
    
    def _check_package_json_security(self, file_path: str, package_data: Dict[str, Any]) -> List[VulnerabilityFinding]:
        """Check package.json for security issues."""
        findings = []
        
        # Check for known vulnerable packages (simplified example)
        vulnerable_packages = {
            'lodash': ['4.17.15', '4.17.19'],  # Example vulnerable versions
            'moment': ['2.24.0'],
            'request': ['*']  # Deprecated package
        }
        
        for dep_type in ['dependencies', 'devDependencies']:
            if dep_type in package_data:
                for package_name, version in package_data[dep_type].items():
                    if package_name in vulnerable_packages:
                        finding = VulnerabilityFinding(
                            finding_id=f"npm_vulnerable_package_{uuid.uuid4().hex[:8]}",
                            vulnerability_type=VulnerabilityType.VULNERABLE_COMPONENTS,
                            title=f"Vulnerable NPM Package: {package_name}",
                            description=f"Package {package_name}@{version} has known vulnerabilities",
                            severity=SecurityTestSeverity.HIGH,
                            threat_level=ThreatLevel.HIGH,
                            confidence=0.9,
                            file_path=file_path,
                            scanning_technique=ScanningTechnique.DEPENDENCY_SCANNING,
                            detection_algorithm="npm_vulnerability_checker",
                            remediation_guidance=f"Update {package_name} to latest secure version",
                            affected_compliance_frameworks=[ComplianceFramework.OWASP_TOP10],
                            owasp_category="A06:2021 – Vulnerable and Outdated Components"
                        )
                        findings.append(finding)
        
        return findings
    
    async def _perform_security_checks(self, target_path: str, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Perform additional security checks using custom rules."""
        findings = []
        
        # Prepare target context for custom rules
        target_context = {
            "target_path": target_path,
            "source_files": self._get_source_file_contents(target_path, config),
            "configuration": config
        }
        
        # Execute custom security rules
        for rule in self.vulnerability_db.custom_rules:
            try:
                rule_findings = rule["check_function"](target_context)
                findings.extend(rule_findings)
            except Exception as e:
                self.logger.warning(f"Custom rule {rule['rule_id']} failed: {e}")
        
        return findings
    
    def _get_source_file_contents(self, target_path: str, config: ScanConfiguration) -> List[Tuple[str, str]]:
        """Get source file contents for custom rule analysis."""
        source_files = []
        source_file_paths = self._discover_source_files(target_path, config)
        
        for file_path in source_file_paths[:50]:  # Limit for performance
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                source_files.append((file_path, content))
            except Exception as e:
                self.logger.warning(f"Failed to read file {file_path}: {e}")
        
        return source_files


class DynamicAnalysisScanner:
    """
    Dynamic analysis vulnerability scanner for runtime security assessment.
    
    Implements runtime vulnerability detection including penetration testing,
    behavioral analysis, and real-time threat detection per Section 6.4.5.
    """
    
    def __init__(self, vulnerability_db: VulnerabilityDatabase):
        self.logger = scanner_logger.bind(component="dynamic_analysis_scanner")
        self.vulnerability_db = vulnerability_db
        self.session = requests.Session()
        self.session.timeout = 30
        
        # Configure session with security testing headers
        self.session.headers.update({
            'User-Agent': 'Security-Vulnerability-Scanner/1.0',
            'Accept': 'application/json, text/html, application/xml, */*'
        })
    
    async def scan_application(self, target_url: str, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Perform comprehensive dynamic analysis of web application."""
        findings = []
        scan_start = time.time()
        
        try:
            self.logger.info(f"Starting dynamic analysis of {target_url}")
            
            # Application discovery and reconnaissance
            discovery_findings = await self._perform_application_discovery(target_url, config)
            findings.extend(discovery_findings)
            
            # Authentication and session testing
            auth_findings = await self._test_authentication_security(target_url, config)
            findings.extend(auth_findings)
            
            # Input validation and injection testing
            injection_findings = await self._test_injection_vulnerabilities(target_url, config)
            findings.extend(injection_findings)
            
            # XSS and client-side vulnerability testing
            xss_findings = await self._test_xss_vulnerabilities(target_url, config)
            findings.extend(xss_findings)
            
            # Security headers and configuration testing
            header_findings = await self._test_security_headers(target_url, config)
            findings.extend(header_findings)
            
            # Business logic and workflow testing
            logic_findings = await self._test_business_logic(target_url, config)
            findings.extend(logic_findings)
            
            # API security testing
            api_findings = await self._test_api_security(target_url, config)
            findings.extend(api_findings)
            
            # Record metrics
            scan_duration = time.time() - scan_start
            vulnerability_metrics['scan_duration_seconds'].labels(
                scan_type='dynamic_analysis',
                target_type=config.target_type
            ).observe(scan_duration)
            
            self.logger.info(f"Dynamic analysis completed in {scan_duration:.2f}s with {len(findings)} findings")
            return findings
            
        except Exception as e:
            self.logger.error(f"Dynamic analysis scan failed: {e}")
            raise
    
    async def _perform_application_discovery(self, target_url: str, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Perform application discovery and reconnaissance."""
        findings = []
        
        try:
            # Test base URL accessibility
            response = self.session.get(target_url)
            
            # Check for information disclosure in headers
            sensitive_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
            for header in sensitive_headers:
                if header in response.headers:
                    finding = VulnerabilityFinding(
                        finding_id=f"info_disclosure_header_{uuid.uuid4().hex[:8]}",
                        vulnerability_type=VulnerabilityType.INFORMATION_DISCLOSURE,
                        title=f"Information Disclosure in {header} Header",
                        description=f"Server information disclosed in {header} header: {response.headers[header]}",
                        severity=SecurityTestSeverity.LOW,
                        threat_level=ThreatLevel.LOW,
                        confidence=0.8,
                        url_endpoint=target_url,
                        scanning_technique=ScanningTechnique.DYNAMIC_ANALYSIS,
                        detection_algorithm="header_information_disclosure",
                        remediation_guidance=f"Remove or sanitize {header} header to prevent information disclosure"
                    )
                    findings.append(finding)
            
            # Check for debug mode indicators
            debug_indicators = ['debug', 'traceback', 'stack trace', 'django', 'flask']
            response_text = response.text.lower()
            
            for indicator in debug_indicators:
                if indicator in response_text:
                    finding = VulnerabilityFinding(
                        finding_id=f"debug_mode_indicator_{uuid.uuid4().hex[:8]}",
                        vulnerability_type=VulnerabilityType.SECURITY_MISCONFIGURATION,
                        title="Debug Mode Indicators Detected",
                        description=f"Debug information or framework details detected in response",
                        severity=SecurityTestSeverity.MEDIUM,
                        threat_level=ThreatLevel.MEDIUM,
                        confidence=0.6,
                        url_endpoint=target_url,
                        scanning_technique=ScanningTechnique.DYNAMIC_ANALYSIS,
                        detection_algorithm="debug_mode_detector",
                        remediation_guidance="Disable debug mode in production environment"
                    )
                    findings.append(finding)
                    break
            
        except requests.RequestException as e:
            self.logger.warning(f"Application discovery failed: {e}")
        
        return findings
    
    async def _test_authentication_security(self, target_url: str, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Test authentication and session security."""
        findings = []
        
        try:
            # Test for authentication bypass
            auth_endpoints = ['/login', '/auth', '/signin', '/api/auth/login']
            
            for endpoint in auth_endpoints:
                full_url = urljoin(target_url, endpoint)
                
                # Test SQL injection in authentication
                sql_payloads = ["admin'--", "' OR '1'='1", "admin' OR '1'='1'--"]
                
                for payload in sql_payloads:
                    try:
                        auth_data = {
                            'username': payload,
                            'password': 'password',
                            'email': payload
                        }
                        
                        response = self.session.post(full_url, data=auth_data, timeout=10)
                        
                        # Check for successful authentication bypass
                        success_indicators = ['welcome', 'dashboard', 'success', 'token', 'authenticated']
                        response_text = response.text.lower()
                        
                        if (response.status_code == 200 and 
                            any(indicator in response_text for indicator in success_indicators)):
                            
                            finding = VulnerabilityFinding(
                                finding_id=f"auth_sql_injection_{uuid.uuid4().hex[:8]}",
                                vulnerability_type=VulnerabilityType.SQL_INJECTION,
                                title="SQL Injection in Authentication",
                                description=f"Potential SQL injection bypass in authentication endpoint",
                                severity=SecurityTestSeverity.CRITICAL,
                                threat_level=ThreatLevel.CRITICAL,
                                confidence=0.8,
                                url_endpoint=full_url,
                                http_method="POST",
                                scanning_technique=ScanningTechnique.PENETRATION_TESTING,
                                detection_algorithm="auth_sql_injection_tester",
                                proof_of_concept=f"POST {full_url} with username='{payload}'",
                                remediation_guidance="Use parameterized queries and input validation for authentication",
                                affected_compliance_frameworks=[ComplianceFramework.OWASP_TOP10],
                                owasp_category="A03:2021 – Injection",
                                cwe_ids=["CWE-89"]
                            )
                            findings.append(finding)
                    
                    except requests.RequestException:
                        continue
                    
                    # Rate limiting delay
                    await asyncio.sleep(config.rate_limit_delay)
        
        except Exception as e:
            self.logger.warning(f"Authentication testing failed: {e}")
        
        return findings
    
    async def _test_injection_vulnerabilities(self, target_url: str, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Test for various injection vulnerabilities."""
        findings = []
        
        # Test endpoints for injection vulnerabilities
        test_endpoints = ['/search', '/api/users', '/api/search', '/query']
        
        # SQL injection payloads
        sql_payloads = [
            "'; DROP TABLE users; --",
            "' UNION SELECT 1,2,3--",
            "' OR 1=1--",
            "' AND (SELECT SUBSTRING(version(),1,1))='5'--"
        ]
        
        # NoSQL injection payloads (for MongoDB)
        nosql_payloads = [
            '{"$gt":""}',
            '{"$ne":null}',
            '{"$regex":".*"}',
            '{"$where":"this.username == this.password"}'
        ]
        
        # Command injection payloads
        command_payloads = [
            "; cat /etc/passwd",
            "| whoami",
            "&& id",
            "`uname -a`"
        ]
        
        for endpoint in test_endpoints:
            full_url = urljoin(target_url, endpoint)
            
            # Test SQL injection
            for payload in sql_payloads:
                await self._test_injection_payload(full_url, payload, VulnerabilityType.SQL_INJECTION, findings, config)
            
            # Test NoSQL injection
            for payload in nosql_payloads:
                await self._test_injection_payload(full_url, payload, VulnerabilityType.DATABASE_INJECTION, findings, config)
            
            # Test command injection
            for payload in command_payloads:
                await self._test_injection_payload(full_url, payload, VulnerabilityType.COMMAND_INJECTION, findings, config)
        
        return findings
    
    async def _test_injection_payload(self, url: str, payload: str, vuln_type: VulnerabilityType, findings: List[VulnerabilityFinding], config: ScanConfiguration):
        """Test individual injection payload against endpoint."""
        try:
            # Test GET parameters
            get_response = self.session.get(url, params={'q': payload, 'search': payload}, timeout=10)
            
            # Test POST data
            post_response = self.session.post(url, data={'query': payload, 'input': payload}, timeout=10)
            
            # Test JSON payload
            json_response = self.session.post(url, json={'query': payload, 'search': payload}, timeout=10)
            
            for response in [get_response, post_response, json_response]:
                if self._detect_injection_vulnerability(response, payload, vuln_type):
                    finding = VulnerabilityFinding(
                        finding_id=f"{vuln_type.value}_injection_{uuid.uuid4().hex[:8]}",
                        vulnerability_type=vuln_type,
                        title=f"{vuln_type.value.replace('_', ' ').title()} Injection Detected",
                        description=f"Potential {vuln_type.value} injection vulnerability detected",
                        severity=SecurityTestSeverity.HIGH,
                        threat_level=ThreatLevel.HIGH,
                        confidence=0.7,
                        url_endpoint=url,
                        http_method=response.request.method,
                        scanning_technique=ScanningTechnique.PENETRATION_TESTING,
                        detection_algorithm="injection_payload_tester",
                        proof_of_concept=f"{response.request.method} {url} with payload: {payload}",
                        remediation_guidance="Use parameterized queries and input validation",
                        affected_compliance_frameworks=[ComplianceFramework.OWASP_TOP10],
                        owasp_category="A03:2021 – Injection"
                    )
                    findings.append(finding)
                    break  # Avoid duplicate findings for same vulnerability
        
        except requests.RequestException:
            pass  # Continue with next payload
        
        # Rate limiting delay
        await asyncio.sleep(config.rate_limit_delay)
    
    def _detect_injection_vulnerability(self, response: requests.Response, payload: str, vuln_type: VulnerabilityType) -> bool:
        """Detect injection vulnerability based on response characteristics."""
        response_text = response.text.lower()
        
        # SQL injection detection
        if vuln_type == VulnerabilityType.SQL_INJECTION:
            sql_error_indicators = [
                'sql syntax', 'mysql_fetch', 'ora-', 'microsoft jet',
                'odbc', 'sqlite', 'postgresql', 'syntax error'
            ]
            return any(indicator in response_text for indicator in sql_error_indicators)
        
        # Command injection detection
        elif vuln_type == VulnerabilityType.COMMAND_INJECTION:
            command_indicators = [
                'uid=', 'gid=', 'root:', '/bin/', '/usr/', 'linux',
                'windows', 'system32', 'command not found'
            ]
            return any(indicator in response_text for indicator in command_indicators)
        
        # NoSQL injection detection
        elif vuln_type == VulnerabilityType.DATABASE_INJECTION:
            nosql_indicators = [
                'mongodb', 'bson', 'objectid', 'invalid bson',
                'query failed', 'aggregation pipeline'
            ]
            return any(indicator in response_text for indicator in nosql_indicators)
        
        return False
    
    async def _test_xss_vulnerabilities(self, target_url: str, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Test for Cross-Site Scripting vulnerabilities."""
        findings = []
        
        # XSS payloads
        xss_payloads = [
            '<script>alert("XSS")</script>',
            'javascript:alert("XSS")',
            '<img src=x onerror=alert("XSS")>',
            '<svg onload=alert("XSS")>',
            '"><script>alert("XSS")</script>',
            '<iframe src="javascript:alert(\'XSS\')">',
            '<body onload=alert("XSS")>'
        ]
        
        # Test endpoints
        test_endpoints = ['/search', '/comment', '/feedback', '/contact']
        
        for endpoint in test_endpoints:
            full_url = urljoin(target_url, endpoint)
            
            for payload in xss_payloads:
                try:
                    # Test reflected XSS
                    response = self.session.get(full_url, params={'q': payload}, timeout=10)
                    
                    if payload in response.text:
                        finding = VulnerabilityFinding(
                            finding_id=f"reflected_xss_{uuid.uuid4().hex[:8]}",
                            vulnerability_type=VulnerabilityType.CROSS_SITE_SCRIPTING,
                            title="Reflected Cross-Site Scripting (XSS)",
                            description="Reflected XSS vulnerability detected in response",
                            severity=SecurityTestSeverity.HIGH,
                            threat_level=ThreatLevel.HIGH,
                            confidence=0.9,
                            url_endpoint=full_url,
                            http_method="GET",
                            scanning_technique=ScanningTechnique.PENETRATION_TESTING,
                            detection_algorithm="reflected_xss_tester",
                            proof_of_concept=f"GET {full_url}?q={payload}",
                            remediation_guidance="Implement proper output encoding and input validation",
                            affected_compliance_frameworks=[ComplianceFramework.OWASP_TOP10],
                            owasp_category="A03:2021 – Injection",
                            cwe_ids=["CWE-79"]
                        )
                        findings.append(finding)
                    
                    # Test stored XSS (POST request)
                    post_response = self.session.post(full_url, data={'comment': payload}, timeout=10)
                    
                    if post_response.status_code == 200:
                        # Check if payload is stored (simplified check)
                        verify_response = self.session.get(full_url, timeout=10)
                        if payload in verify_response.text:
                            finding = VulnerabilityFinding(
                                finding_id=f"stored_xss_{uuid.uuid4().hex[:8]}",
                                vulnerability_type=VulnerabilityType.CROSS_SITE_SCRIPTING,
                                title="Stored Cross-Site Scripting (XSS)",
                                description="Stored XSS vulnerability detected",
                                severity=SecurityTestSeverity.CRITICAL,
                                threat_level=ThreatLevel.CRITICAL,
                                confidence=0.95,
                                url_endpoint=full_url,
                                http_method="POST",
                                scanning_technique=ScanningTechnique.PENETRATION_TESTING,
                                detection_algorithm="stored_xss_tester",
                                proof_of_concept=f"POST {full_url} with comment={payload}",
                                remediation_guidance="Implement proper output encoding, input validation, and CSP",
                                affected_compliance_frameworks=[ComplianceFramework.OWASP_TOP10],
                                owasp_category="A03:2021 – Injection",
                                cwe_ids=["CWE-79"]
                            )
                            findings.append(finding)
                
                except requests.RequestException:
                    continue
                
                # Rate limiting delay
                await asyncio.sleep(config.rate_limit_delay)
        
        return findings
    
    async def _test_security_headers(self, target_url: str, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Test security headers configuration."""
        findings = []
        
        try:
            response = self.session.get(target_url)
            headers = response.headers
            
            # Required security headers
            required_headers = {
                'Strict-Transport-Security': {
                    'severity': SecurityTestSeverity.HIGH,
                    'description': 'HSTS header missing - connections not forced over HTTPS'
                },
                'Content-Security-Policy': {
                    'severity': SecurityTestSeverity.MEDIUM,
                    'description': 'CSP header missing - no XSS protection policy'
                },
                'X-Content-Type-Options': {
                    'severity': SecurityTestSeverity.MEDIUM,
                    'description': 'X-Content-Type-Options header missing - MIME sniffing not prevented'
                },
                'X-Frame-Options': {
                    'severity': SecurityTestSeverity.MEDIUM,
                    'description': 'X-Frame-Options header missing - clickjacking protection disabled'
                },
                'Referrer-Policy': {
                    'severity': SecurityTestSeverity.LOW,
                    'description': 'Referrer-Policy header missing - referrer information may leak'
                }
            }
            
            for header_name, header_config in required_headers.items():
                if header_name not in headers:
                    finding = VulnerabilityFinding(
                        finding_id=f"missing_security_header_{uuid.uuid4().hex[:8]}",
                        vulnerability_type=VulnerabilityType.FLASK_SECURITY_HEADERS,
                        title=f"Missing Security Header: {header_name}",
                        description=header_config['description'],
                        severity=header_config['severity'],
                        threat_level=ThreatLevel.MEDIUM,
                        confidence=1.0,
                        url_endpoint=target_url,
                        scanning_technique=ScanningTechnique.DYNAMIC_ANALYSIS,
                        detection_algorithm="security_header_checker",
                        remediation_guidance=f"Implement {header_name} security header with appropriate values",
                        affected_compliance_frameworks=[ComplianceFramework.OWASP_TOP10],
                        owasp_category="A05:2021 – Security Misconfiguration"
                    )
                    findings.append(finding)
            
            # Check for insecure header values
            if 'X-Frame-Options' in headers and headers['X-Frame-Options'].upper() == 'ALLOWALL':
                finding = VulnerabilityFinding(
                    finding_id=f"insecure_xframe_options_{uuid.uuid4().hex[:8]}",
                    vulnerability_type=VulnerabilityType.FLASK_SECURITY_HEADERS,
                    title="Insecure X-Frame-Options Configuration",
                    description="X-Frame-Options set to ALLOWALL - clickjacking protection disabled",
                    severity=SecurityTestSeverity.MEDIUM,
                    threat_level=ThreatLevel.MEDIUM,
                    confidence=1.0,
                    url_endpoint=target_url,
                    scanning_technique=ScanningTechnique.DYNAMIC_ANALYSIS,
                    detection_algorithm="header_value_checker",
                    remediation_guidance="Set X-Frame-Options to DENY or SAMEORIGIN"
                )
                findings.append(finding)
        
        except requests.RequestException as e:
            self.logger.warning(f"Security headers testing failed: {e}")
        
        return findings
    
    async def _test_business_logic(self, target_url: str, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Test business logic vulnerabilities."""
        findings = []
        
        # Test for common business logic issues
        try:
            # Test for privilege escalation
            findings.extend(await self._test_privilege_escalation(target_url, config))
            
            # Test for race conditions
            findings.extend(await self._test_race_conditions(target_url, config))
            
            # Test for business logic bypass
            findings.extend(await self._test_business_logic_bypass(target_url, config))
        
        except Exception as e:
            self.logger.warning(f"Business logic testing failed: {e}")
        
        return findings
    
    async def _test_privilege_escalation(self, target_url: str, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Test for privilege escalation vulnerabilities."""
        findings = []
        
        # Test parameter manipulation
        admin_endpoints = ['/admin', '/api/admin', '/admin/users', '/admin/settings']
        
        for endpoint in admin_endpoints:
            full_url = urljoin(target_url, endpoint)
            
            try:
                # Test direct access to admin endpoints
                response = self.session.get(full_url, timeout=10)
                
                if response.status_code == 200:
                    # Check if admin content is accessible without authentication
                    admin_indicators = ['admin', 'dashboard', 'users', 'settings', 'control panel']
                    response_text = response.text.lower()
                    
                    if any(indicator in response_text for indicator in admin_indicators):
                        finding = VulnerabilityFinding(
                            finding_id=f"privilege_escalation_{uuid.uuid4().hex[:8]}",
                            vulnerability_type=VulnerabilityType.BROKEN_ACCESS_CONTROL,
                            title="Unauthorized Access to Admin Endpoint",
                            description=f"Admin endpoint accessible without proper authentication: {endpoint}",
                            severity=SecurityTestSeverity.HIGH,
                            threat_level=ThreatLevel.HIGH,
                            confidence=0.8,
                            url_endpoint=full_url,
                            scanning_technique=ScanningTechnique.PENETRATION_TESTING,
                            detection_algorithm="privilege_escalation_tester",
                            remediation_guidance="Implement proper access controls and authentication for admin endpoints",
                            affected_compliance_frameworks=[ComplianceFramework.OWASP_TOP10],
                            owasp_category="A01:2021 – Broken Access Control"
                        )
                        findings.append(finding)
            
            except requests.RequestException:
                continue
        
        return findings
    
    async def _test_race_conditions(self, target_url: str, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Test for race condition vulnerabilities."""
        findings = []
        
        # This is a simplified race condition test
        # In practice, this would involve concurrent requests and timing analysis
        
        return findings  # Placeholder for race condition testing
    
    async def _test_business_logic_bypass(self, target_url: str, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Test for business logic bypass vulnerabilities."""
        findings = []
        
        # Test for common business logic bypasses
        # This is a simplified implementation
        
        return findings  # Placeholder for business logic bypass testing
    
    async def _test_api_security(self, target_url: str, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Test API-specific security vulnerabilities."""
        findings = []
        
        # Test for common API security issues
        api_endpoints = ['/api', '/api/v1', '/api/users', '/api/auth']
        
        for endpoint in api_endpoints:
            full_url = urljoin(target_url, endpoint)
            
            try:
                # Test for information disclosure in API responses
                response = self.session.get(full_url, timeout=10)
                
                if response.status_code == 200:
                    try:
                        json_response = response.json()
                        
                        # Check for sensitive information in API response
                        sensitive_keys = ['password', 'secret', 'token', 'key', 'hash']
                        
                        if self._contains_sensitive_data(json_response, sensitive_keys):
                            finding = VulnerabilityFinding(
                                finding_id=f"api_info_disclosure_{uuid.uuid4().hex[:8]}",
                                vulnerability_type=VulnerabilityType.INFORMATION_DISCLOSURE,
                                title="Sensitive Information in API Response",
                                description="API endpoint returns sensitive information",
                                severity=SecurityTestSeverity.MEDIUM,
                                threat_level=ThreatLevel.MEDIUM,
                                confidence=0.7,
                                url_endpoint=full_url,
                                scanning_technique=ScanningTechnique.DYNAMIC_ANALYSIS,
                                detection_algorithm="api_sensitive_data_checker",
                                remediation_guidance="Remove sensitive information from API responses",
                                affected_compliance_frameworks=[ComplianceFramework.OWASP_TOP10]
                            )
                            findings.append(finding)
                    
                    except json.JSONDecodeError:
                        pass  # Not a JSON response
            
            except requests.RequestException:
                continue
        
        return findings
    
    def _contains_sensitive_data(self, data: Any, sensitive_keys: List[str]) -> bool:
        """Check if data structure contains sensitive information."""
        if isinstance(data, dict):
            for key, value in data.items():
                if any(sensitive_key in key.lower() for sensitive_key in sensitive_keys):
                    return True
                if self._contains_sensitive_data(value, sensitive_keys):
                    return True
        elif isinstance(data, list):
            for item in data:
                if self._contains_sensitive_data(item, sensitive_keys):
                    return True
        
        return False


class DependencyScanner:
    """
    Dependency vulnerability scanner for third-party component security assessment.
    
    Implements comprehensive dependency analysis including license compliance,
    known vulnerability detection, and supply chain security per Section 6.4.5.
    """
    
    def __init__(self, vulnerability_db: VulnerabilityDatabase):
        self.logger = scanner_logger.bind(component="dependency_scanner")
        self.vulnerability_db = vulnerability_db
    
    async def scan_dependencies(self, project_path: str, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Scan project dependencies for vulnerabilities."""
        findings = []
        scan_start = time.time()
        
        try:
            self.logger.info(f"Starting dependency scan of {project_path}")
            
            # Python dependencies scanning
            python_findings = await self._scan_python_dependencies(project_path, config)
            findings.extend(python_findings)
            
            # JavaScript/Node.js dependencies scanning
            npm_findings = await self._scan_npm_dependencies(project_path, config)
            findings.extend(npm_findings)
            
            # License compliance checking
            license_findings = await self._check_license_compliance(project_path, config)
            findings.extend(license_findings)
            
            # Supply chain security assessment
            supply_chain_findings = await self._assess_supply_chain_security(project_path, config)
            findings.extend(supply_chain_findings)
            
            # Record metrics
            scan_duration = time.time() - scan_start
            vulnerability_metrics['scan_duration_seconds'].labels(
                scan_type='dependency_scanning',
                target_type=config.target_type
            ).observe(scan_duration)
            
            self.logger.info(f"Dependency scan completed in {scan_duration:.2f}s with {len(findings)} findings")
            return findings
            
        except Exception as e:
            self.logger.error(f"Dependency scan failed: {e}")
            raise
    
    async def _scan_python_dependencies(self, project_path: str, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Scan Python dependencies using safety and pip-audit."""
        findings = []
        
        # Look for requirements files
        requirements_files = []
        for req_file in ['requirements.txt', 'requirements-dev.txt', 'Pipfile', 'pyproject.toml']:
            req_path = Path(project_path) / req_file
            if req_path.exists():
                requirements_files.append(str(req_path))
        
        if not requirements_files:
            return findings
        
        # Run safety check
        safety_findings = await self._run_safety_check(requirements_files, config)
        findings.extend(safety_findings)
        
        # Run pip-audit check
        pip_audit_findings = await self._run_pip_audit_check(project_path, config)
        findings.extend(pip_audit_findings)
        
        return findings
    
    async def _run_safety_check(self, requirements_files: List[str], config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Run safety vulnerability check on Python dependencies."""
        findings = []
        
        try:
            for req_file in requirements_files:
                cmd = ['safety', 'check', '--json', '--file', req_file]
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
                
                if result.stdout:
                    try:
                        safety_output = json.loads(result.stdout)
                        
                        for vulnerability in safety_output:
                            finding = VulnerabilityFinding(
                                finding_id=f"safety_{uuid.uuid4().hex[:8]}",
                                vulnerability_type=VulnerabilityType.VULNERABLE_COMPONENTS,
                                title=f"Vulnerable Python Package: {vulnerability.get('package', 'Unknown')}",
                                description=vulnerability.get('advisory', 'Known vulnerability in Python package'),
                                severity=self._map_safety_severity(vulnerability.get('severity', 'medium')),
                                threat_level=ThreatLevel.HIGH,
                                confidence=0.9,
                                file_path=req_file,
                                scanning_technique=ScanningTechnique.DEPENDENCY_SCANNING,
                                detection_algorithm="safety",
                                cvss_score=vulnerability.get('cvss'),
                                cve_ids=[vulnerability.get('cve', '')] if vulnerability.get('cve') else [],
                                remediation_guidance=f"Update {vulnerability.get('package')} to version {vulnerability.get('safe_version', 'latest')}",
                                affected_compliance_frameworks=[ComplianceFramework.OWASP_TOP10],
                                owasp_category="A06:2021 – Vulnerable and Outdated Components"
                            )
                            findings.append(finding)
                    
                    except json.JSONDecodeError:
                        self.logger.warning(f"Failed to parse safety output for {req_file}")
        
        except subprocess.TimeoutExpired:
            self.logger.warning("Safety check timed out")
        except Exception as e:
            self.logger.warning(f"Safety check failed: {e}")
        
        return findings
    
    def _map_safety_severity(self, safety_severity: str) -> SecurityTestSeverity:
        """Map safety severity to internal severity levels."""
        severity_map = {
            'low': SecurityTestSeverity.LOW,
            'medium': SecurityTestSeverity.MEDIUM,
            'high': SecurityTestSeverity.HIGH,
            'critical': SecurityTestSeverity.CRITICAL
        }
        return severity_map.get(safety_severity.lower(), SecurityTestSeverity.MEDIUM)
    
    async def _run_pip_audit_check(self, project_path: str, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Run pip-audit vulnerability check."""
        findings = []
        
        try:
            cmd = ['pip-audit', '--format', 'json', '--progress-spinner', 'off']
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=120, cwd=project_path)
            
            if result.stdout:
                try:
                    audit_output = json.loads(result.stdout)
                    
                    for vulnerability in audit_output.get('vulnerabilities', []):
                        finding = VulnerabilityFinding(
                            finding_id=f"pip_audit_{uuid.uuid4().hex[:8]}",
                            vulnerability_type=VulnerabilityType.VULNERABLE_COMPONENTS,
                            title=f"Vulnerable Package: {vulnerability.get('package', 'Unknown')}",
                            description=vulnerability.get('description', 'Known vulnerability detected by pip-audit'),
                            severity=SecurityTestSeverity.HIGH,
                            threat_level=ThreatLevel.HIGH,
                            confidence=0.95,
                            scanning_technique=ScanningTechnique.DEPENDENCY_SCANNING,
                            detection_algorithm="pip-audit",
                            cve_ids=vulnerability.get('cves', []),
                            remediation_guidance=f"Update package to a secure version: {vulnerability.get('fix_versions', 'latest')}",
                            affected_compliance_frameworks=[ComplianceFramework.OWASP_TOP10]
                        )
                        findings.append(finding)
                
                except json.JSONDecodeError:
                    self.logger.warning("Failed to parse pip-audit output")
        
        except subprocess.TimeoutExpired:
            self.logger.warning("pip-audit check timed out")
        except Exception as e:
            self.logger.warning(f"pip-audit check failed: {e}")
        
        return findings
    
    async def _scan_npm_dependencies(self, project_path: str, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Scan NPM dependencies for vulnerabilities."""
        findings = []
        
        # Check for package.json
        package_json_path = Path(project_path) / 'package.json'
        if not package_json_path.exists():
            return findings
        
        try:
            # Run npm audit
            cmd = ['npm', 'audit', '--json']
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=120, cwd=project_path)
            
            if result.stdout:
                try:
                    audit_output = json.loads(result.stdout)
                    
                    for vuln_id, vulnerability in audit_output.get('vulnerabilities', {}).items():
                        severity_map = {
                            'low': SecurityTestSeverity.LOW,
                            'moderate': SecurityTestSeverity.MEDIUM,
                            'high': SecurityTestSeverity.HIGH,
                            'critical': SecurityTestSeverity.CRITICAL
                        }
                        
                        finding = VulnerabilityFinding(
                            finding_id=f"npm_audit_{uuid.uuid4().hex[:8]}",
                            vulnerability_type=VulnerabilityType.VULNERABLE_COMPONENTS,
                            title=f"Vulnerable NPM Package: {vulnerability.get('name', 'Unknown')}",
                            description=vulnerability.get('title', 'Known vulnerability in NPM package'),
                            severity=severity_map.get(vulnerability.get('severity', 'medium'), SecurityTestSeverity.MEDIUM),
                            threat_level=ThreatLevel.HIGH,
                            confidence=0.9,
                            file_path=str(package_json_path),
                            scanning_technique=ScanningTechnique.DEPENDENCY_SCANNING,
                            detection_algorithm="npm-audit",
                            cve_ids=vulnerability.get('cves', []),
                            remediation_guidance=f"Update to version {vulnerability.get('patched_versions', 'latest')}",
                            affected_compliance_frameworks=[ComplianceFramework.OWASP_TOP10]
                        )
                        findings.append(finding)
                
                except json.JSONDecodeError:
                    self.logger.warning("Failed to parse npm audit output")
        
        except subprocess.TimeoutExpired:
            self.logger.warning("npm audit timed out")
        except Exception as e:
            self.logger.warning(f"npm audit failed: {e}")
        
        return findings
    
    async def _check_license_compliance(self, project_path: str, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Check dependency license compliance."""
        findings = []
        
        # Restricted licenses that may pose compliance risks
        restricted_licenses = [
            'GPL-3.0', 'AGPL-3.0', 'SSPL-1.0', 'Commons Clause',
            'Elastic License', 'Server Side Public License'
        ]
        
        # This is a simplified license check
        # In practice, you would use specialized tools like license-checker
        
        return findings  # Placeholder for license compliance checking
    
    async def _assess_supply_chain_security(self, project_path: str, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Assess supply chain security risks."""
        findings = []
        
        # Check for package integrity and authenticity
        # Check for typosquatting risks
        # Check for maintainer security
        # This is a placeholder for comprehensive supply chain analysis
        
        return findings  # Placeholder for supply chain security assessment


class VulnerabilityScanner:
    """
    Comprehensive vulnerability scanning framework for enterprise security assessment.
    
    Integrates static analysis, dynamic testing, dependency scanning, and compliance
    validation to provide complete security posture assessment per Section 6.4.5.
    """
    
    def __init__(self, security_config: SecurityTestConfiguration):
        self.logger = scanner_logger.bind(component="vulnerability_scanner")
        self.security_config = security_config
        
        # Initialize components
        self.vulnerability_db = VulnerabilityDatabase()
        self.static_scanner = StaticAnalysisScanner(self.vulnerability_db)
        self.dynamic_scanner = DynamicAnalysisScanner(self.vulnerability_db)
        self.dependency_scanner = DependencyScanner(self.vulnerability_db)
        
        # Metrics registry for vulnerability scanning
        self.metrics_registry = CollectorRegistry()
        self._register_metrics()
        
        self.logger.info("Vulnerability scanner initialized successfully")
    
    def _register_metrics(self):
        """Register custom metrics for vulnerability scanning."""
        for metric_name, metric in vulnerability_metrics.items():
            self.metrics_registry.register(metric)
    
    async def scan_target(self, scan_config: ScanConfiguration) -> ScanResult:
        """
        Perform comprehensive vulnerability scan of target.
        
        Args:
            scan_config: Scan configuration specifying target and parameters
            
        Returns:
            Complete scan result with findings and analysis
        """
        scan_start = datetime.now(timezone.utc)
        scan_id = scan_config.scan_id
        
        self.logger.info(f"Starting comprehensive vulnerability scan: {scan_id}")
        
        try:
            all_findings = []
            scan_errors = []
            successful_scans = 0
            failed_scans = 0
            
            # Execute enabled scanning techniques
            if ScanningTechnique.STATIC_ANALYSIS in scan_config.enabled_techniques:
                try:
                    static_findings = await self._execute_static_analysis(scan_config)
                    all_findings.extend(static_findings)
                    successful_scans += 1
                    self.logger.info(f"Static analysis completed with {len(static_findings)} findings")
                except Exception as e:
                    scan_errors.append(f"Static analysis failed: {str(e)}")
                    failed_scans += 1
                    self.logger.error(f"Static analysis failed: {e}")
            
            if ScanningTechnique.DYNAMIC_ANALYSIS in scan_config.enabled_techniques:
                try:
                    dynamic_findings = await self._execute_dynamic_analysis(scan_config)
                    all_findings.extend(dynamic_findings)
                    successful_scans += 1
                    self.logger.info(f"Dynamic analysis completed with {len(dynamic_findings)} findings")
                except Exception as e:
                    scan_errors.append(f"Dynamic analysis failed: {str(e)}")
                    failed_scans += 1
                    self.logger.error(f"Dynamic analysis failed: {e}")
            
            if ScanningTechnique.DEPENDENCY_SCANNING in scan_config.enabled_techniques:
                try:
                    dependency_findings = await self._execute_dependency_scanning(scan_config)
                    all_findings.extend(dependency_findings)
                    successful_scans += 1
                    self.logger.info(f"Dependency scanning completed with {len(dependency_findings)} findings")
                except Exception as e:
                    scan_errors.append(f"Dependency scanning failed: {str(e)}")
                    failed_scans += 1
                    self.logger.error(f"Dependency scanning failed: {e}")
            
            if ScanningTechnique.PENETRATION_TESTING in scan_config.enabled_techniques:
                try:
                    pentest_findings = await self._execute_penetration_testing(scan_config)
                    all_findings.extend(pentest_findings)
                    successful_scans += 1
                    self.logger.info(f"Penetration testing completed with {len(pentest_findings)} findings")
                except Exception as e:
                    scan_errors.append(f"Penetration testing failed: {str(e)}")
                    failed_scans += 1
                    self.logger.error(f"Penetration testing failed: {e}")
            
            # Process and analyze findings
            processed_findings = self._process_findings(all_findings, scan_config)
            
            # Perform compliance assessment
            compliance_results = await self._assess_compliance(processed_findings, scan_config)
            
            # Calculate security posture score
            security_posture_score = self._calculate_security_posture_score(processed_findings, compliance_results)
            
            # Generate remediation recommendations
            remediation_summary = self._generate_remediation_summary(processed_findings)
            
            # Create scan result
            scan_end = datetime.now(timezone.utc)
            scan_duration = (scan_end - scan_start).total_seconds()
            
            scan_result = ScanResult(
                scan_id=scan_id,
                scan_configuration=scan_config,
                start_time=scan_start,
                end_time=scan_end,
                scan_duration=scan_duration,
                findings=processed_findings,
                total_vulnerabilities=len(processed_findings),
                vulnerabilities_by_severity=self._count_by_severity(processed_findings),
                vulnerabilities_by_type=self._count_by_type(processed_findings),
                successful_scans=successful_scans,
                failed_scans=failed_scans,
                scan_errors=scan_errors,
                compliance_results=compliance_results,
                security_posture_score=security_posture_score,
                remediation_summary=remediation_summary,
                priority_findings=self._identify_priority_findings(processed_findings),
                recommended_actions=self._generate_recommended_actions(processed_findings)
            )
            
            # Record scan metrics
            self._record_scan_metrics(scan_result)
            
            self.logger.info(f"Vulnerability scan completed: {scan_id} in {scan_duration:.2f}s")
            self.logger.info(f"Total findings: {len(processed_findings)}, Security score: {security_posture_score:.2f}")
            
            return scan_result
            
        except Exception as e:
            self.logger.error(f"Vulnerability scan failed: {e}")
            raise
    
    async def _execute_static_analysis(self, scan_config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Execute static analysis scanning."""
        if not scan_config.target_path:
            raise ValueError("Target path required for static analysis")
        
        return await self.static_scanner.scan_codebase(scan_config.target_path, scan_config)
    
    async def _execute_dynamic_analysis(self, scan_config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Execute dynamic analysis scanning."""
        if not scan_config.target_url:
            raise ValueError("Target URL required for dynamic analysis")
        
        return await self.dynamic_scanner.scan_application(scan_config.target_url, scan_config)
    
    async def _execute_dependency_scanning(self, scan_config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Execute dependency vulnerability scanning."""
        if not scan_config.target_path:
            raise ValueError("Target path required for dependency scanning")
        
        return await self.dependency_scanner.scan_dependencies(scan_config.target_path, scan_config)
    
    async def _execute_penetration_testing(self, scan_config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Execute automated penetration testing."""
        # This integrates with the existing penetration testing infrastructure
        # from conftest.py and security_config.py
        
        findings = []
        
        if scan_config.target_url:
            # Use existing attack simulation capabilities
            attack_simulator = AttackSimulator(None, None)  # Would need proper initialization
            
            # Execute OWASP Top 10 attack simulations
            owasp_payloads = OWASPAttackPayloads(SecurityTestConfig())
            
            for attack_type in [AttackType.SQL_INJECTION, AttackType.XSS, AttackType.CSRF]:
                try:
                    payloads = []
                    if attack_type == AttackType.SQL_INJECTION:
                        payloads = owasp_payloads.get_sql_injection_payloads()
                    elif attack_type == AttackType.XSS:
                        payloads = owasp_payloads.get_xss_payloads()
                    elif attack_type == AttackType.CSRF:
                        csrf_payloads = owasp_payloads.get_csrf_payloads()
                        payloads = [str(payload) for payload in csrf_payloads]
                    
                    # Execute penetration test for each payload
                    for payload in payloads[:10]:  # Limit for performance
                        finding = await self._execute_penetration_test_payload(
                            scan_config.target_url, payload, attack_type
                        )
                        if finding:
                            findings.append(finding)
                
                except Exception as e:
                    self.logger.warning(f"Penetration test failed for {attack_type}: {e}")
        
        return findings
    
    async def _execute_penetration_test_payload(self, target_url: str, payload: str, attack_type: AttackType) -> Optional[VulnerabilityFinding]:
        """Execute individual penetration test payload."""
        try:
            # This would integrate with the dynamic scanner
            # Simplified implementation for demonstration
            
            session = requests.Session()
            session.timeout = 10
            
            # Test payload against target
            response = session.get(target_url, params={'test': payload})
            
            # Simple vulnerability detection
            if payload.lower() in response.text.lower():
                return VulnerabilityFinding(
                    finding_id=f"pentest_{attack_type.value}_{uuid.uuid4().hex[:8]}",
                    vulnerability_type=self._map_attack_type_to_vulnerability_type(attack_type),
                    title=f"Penetration Test: {attack_type.value.replace('_', ' ').title()}",
                    description=f"Successful penetration test using {attack_type.value} payload",
                    severity=SecurityTestSeverity.HIGH,
                    threat_level=ThreatLevel.HIGH,
                    confidence=0.8,
                    url_endpoint=target_url,
                    scanning_technique=ScanningTechnique.PENETRATION_TESTING,
                    detection_algorithm="automated_pentest",
                    proof_of_concept=f"GET {target_url}?test={payload}",
                    remediation_guidance="Implement proper input validation and output encoding"
                )
        
        except Exception as e:
            self.logger.warning(f"Penetration test payload failed: {e}")
        
        return None
    
    def _map_attack_type_to_vulnerability_type(self, attack_type: AttackType) -> VulnerabilityType:
        """Map attack type to vulnerability type."""
        mapping = {
            AttackType.SQL_INJECTION: VulnerabilityType.SQL_INJECTION,
            AttackType.XSS: VulnerabilityType.CROSS_SITE_SCRIPTING,
            AttackType.CSRF: VulnerabilityType.CROSS_SITE_REQUEST_FORGERY,
            AttackType.COMMAND_INJECTION: VulnerabilityType.COMMAND_INJECTION,
            AttackType.AUTHENTICATION_BYPASS: VulnerabilityType.AUTHENTICATION_FAILURES,
            AttackType.AUTHORIZATION_BYPASS: VulnerabilityType.BROKEN_ACCESS_CONTROL
        }
        return mapping.get(attack_type, VulnerabilityType.SECURITY_MISCONFIGURATION)
    
    def _process_findings(self, findings: List[VulnerabilityFinding], scan_config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Process and deduplicate vulnerability findings."""
        # Remove duplicates based on vulnerability type, location, and description
        processed_findings = []
        seen_findings = set()
        
        for finding in findings:
            # Create a signature for deduplication
            signature = f"{finding.vulnerability_type.value}:{finding.file_path}:{finding.line_number}:{finding.url_endpoint}:{finding.title}"
            
            if signature not in seen_findings:
                seen_findings.add(signature)
                
                # Apply confidence-based filtering
                if finding.confidence >= 0.5:  # Minimum confidence threshold
                    
                    # Apply false positive analysis
                    finding.false_positive_likelihood = self._calculate_false_positive_likelihood(finding)
                    
                    if not scan_config.include_false_positives and finding.false_positive_likelihood > 0.8:
                        continue  # Skip likely false positives
                    
                    processed_findings.append(finding)
        
        # Sort findings by severity and confidence
        processed_findings.sort(key=lambda f: (f.severity.value, -f.confidence), reverse=True)
        
        return processed_findings
    
    def _calculate_false_positive_likelihood(self, finding: VulnerabilityFinding) -> float:
        """Calculate likelihood of finding being a false positive."""
        # Simplified false positive calculation
        # In practice, this would use machine learning or heuristics
        
        base_likelihood = 0.1  # Base 10% false positive rate
        
        # Adjust based on detection algorithm reliability
        algorithm_reliability = {
            'bandit': 0.9,
            'safety': 0.95,
            'signature_*': 0.7,
            'automated_pentest': 0.6
        }
        
        algorithm = finding.detection_algorithm
        reliability = algorithm_reliability.get(algorithm, 0.8)
        
        # Lower reliability means higher false positive likelihood
        fp_likelihood = base_likelihood + (1.0 - reliability) * 0.3
        
        # Adjust based on confidence
        fp_likelihood = fp_likelihood * (1.0 - finding.confidence)
        
        return min(fp_likelihood, 1.0)
    
    async def _assess_compliance(self, findings: List[VulnerabilityFinding], scan_config: ScanConfiguration) -> Dict[ComplianceFramework, Dict[str, Any]]:
        """Assess compliance against configured frameworks."""
        compliance_results = {}
        
        for framework in scan_config.compliance_frameworks:
            framework_findings = [f for f in findings if framework in f.affected_compliance_frameworks]
            
            if framework == ComplianceFramework.OWASP_TOP10:
                compliance_results[framework] = self._assess_owasp_top10_compliance(framework_findings)
            elif framework == ComplianceFramework.SOC2_TYPE2:
                compliance_results[framework] = self._assess_soc2_compliance(framework_findings)
            elif framework == ComplianceFramework.GDPR:
                compliance_results[framework] = self._assess_gdpr_compliance(framework_findings)
            else:
                # Generic compliance assessment
                compliance_results[framework] = self._assess_generic_compliance(framework_findings, framework)
        
        return compliance_results
    
    def _assess_owasp_top10_compliance(self, findings: List[VulnerabilityFinding]) -> Dict[str, Any]:
        """Assess OWASP Top 10 compliance."""
        owasp_categories = {
            'A01:2021 – Broken Access Control': 0,
            'A02:2021 – Cryptographic Failures': 0,
            'A03:2021 – Injection': 0,
            'A04:2021 – Insecure Design': 0,
            'A05:2021 – Security Misconfiguration': 0,
            'A06:2021 – Vulnerable and Outdated Components': 0,
            'A07:2021 – Identification and Authentication Failures': 0,
            'A08:2021 – Software and Data Integrity Failures': 0,
            'A09:2021 – Security Logging and Monitoring Failures': 0,
            'A10:2021 – Server-Side Request Forgery': 0
        }
        
        # Count findings by OWASP category
        for finding in findings:
            if finding.owasp_category and finding.owasp_category in owasp_categories:
                owasp_categories[finding.owasp_category] += 1
        
        # Calculate compliance score (lower is better)
        total_issues = sum(owasp_categories.values())
        compliance_score = max(0, 100 - (total_issues * 5))  # Deduct 5 points per issue
        
        return {
            'compliance_score': compliance_score,
            'category_breakdown': owasp_categories,
            'total_issues': total_issues,
            'compliant': total_issues == 0,
            'framework': 'OWASP Top 10 2021'
        }
    
    def _assess_soc2_compliance(self, findings: List[VulnerabilityFinding]) -> Dict[str, Any]:
        """Assess SOC 2 Type II compliance."""
        # SOC 2 focuses on security controls
        security_control_issues = len([f for f in findings if f.severity in [SecurityTestSeverity.HIGH, SecurityTestSeverity.CRITICAL]])
        
        compliance_score = max(0, 100 - (security_control_issues * 10))
        
        return {
            'compliance_score': compliance_score,
            'security_control_issues': security_control_issues,
            'compliant': security_control_issues == 0,
            'framework': 'SOC 2 Type II'
        }
    
    def _assess_gdpr_compliance(self, findings: List[VulnerabilityFinding]) -> Dict[str, Any]:
        """Assess GDPR compliance."""
        # GDPR focuses on data protection
        data_protection_issues = len([f for f in findings if 'data' in f.description.lower() or 'privacy' in f.description.lower()])
        
        compliance_score = max(0, 100 - (data_protection_issues * 15))
        
        return {
            'compliance_score': compliance_score,
            'data_protection_issues': data_protection_issues,
            'compliant': data_protection_issues == 0,
            'framework': 'GDPR'
        }
    
    def _assess_generic_compliance(self, findings: List[VulnerabilityFinding], framework: ComplianceFramework) -> Dict[str, Any]:
        """Generic compliance assessment."""
        critical_issues = len([f for f in findings if f.severity == SecurityTestSeverity.CRITICAL])
        high_issues = len([f for f in findings if f.severity == SecurityTestSeverity.HIGH])
        
        compliance_score = max(0, 100 - (critical_issues * 20) - (high_issues * 10))
        
        return {
            'compliance_score': compliance_score,
            'critical_issues': critical_issues,
            'high_issues': high_issues,
            'compliant': critical_issues == 0 and high_issues == 0,
            'framework': framework.value
        }
    
    def _calculate_security_posture_score(self, findings: List[VulnerabilityFinding], compliance_results: Dict[ComplianceFramework, Dict[str, Any]]) -> float:
        """Calculate overall security posture score."""
        # Base score starts at 100
        base_score = 100.0
        
        # Deduct points for vulnerabilities by severity
        severity_weights = {
            SecurityTestSeverity.CRITICAL: 25,
            SecurityTestSeverity.HIGH: 15,
            SecurityTestSeverity.MEDIUM: 5,
            SecurityTestSeverity.LOW: 1
        }
        
        for finding in findings:
            weight = severity_weights.get(finding.severity, 1)
            confidence_factor = finding.confidence
            base_score -= (weight * confidence_factor)
        
        # Factor in compliance scores
        if compliance_results:
            avg_compliance_score = sum(result['compliance_score'] for result in compliance_results.values()) / len(compliance_results)
            base_score = (base_score + avg_compliance_score) / 2
        
        # Ensure score is between 0 and 100
        security_posture_score = max(0.0, min(100.0, base_score))
        
        # Record security posture metric
        vulnerability_metrics['security_posture_score'].labels(
            framework='overall',
            component='application'
        ).set(security_posture_score)
        
        return security_posture_score
    
    def _generate_remediation_summary(self, findings: List[VulnerabilityFinding]) -> Dict[str, Any]:
        """Generate remediation summary and recommendations."""
        remediation_summary = {
            'total_findings': len(findings),
            'critical_findings': len([f for f in findings if f.severity == SecurityTestSeverity.CRITICAL]),
            'high_findings': len([f for f in findings if f.severity == SecurityTestSeverity.HIGH]),
            'medium_findings': len([f for f in findings if f.severity == SecurityTestSeverity.MEDIUM]),
            'low_findings': len([f for f in findings if f.severity == SecurityTestSeverity.LOW]),
            'remediation_categories': {},
            'estimated_effort': 'TBD',
            'priority_order': []
        }
        
        # Group findings by remediation approach
        remediation_categories = {}
        for finding in findings:
            category = self._categorize_remediation(finding)
            if category not in remediation_categories:
                remediation_categories[category] = []
            remediation_categories[category].append(finding)
        
        remediation_summary['remediation_categories'] = {
            category: len(findings_list) for category, findings_list in remediation_categories.items()
        }
        
        # Generate priority order
        priority_findings = sorted(findings, key=lambda f: (f.severity.value, -f.confidence), reverse=True)
        remediation_summary['priority_order'] = [f.finding_id for f in priority_findings[:10]]  # Top 10 priorities
        
        return remediation_summary
    
    def _categorize_remediation(self, finding: VulnerabilityFinding) -> str:
        """Categorize finding by remediation approach."""
        if finding.vulnerability_type in [VulnerabilityType.VULNERABLE_COMPONENTS]:
            return "dependency_updates"
        elif finding.vulnerability_type in [VulnerabilityType.SECURITY_MISCONFIGURATION, VulnerabilityType.FLASK_SECURITY_HEADERS]:
            return "configuration_changes"
        elif finding.vulnerability_type in [VulnerabilityType.SQL_INJECTION, VulnerabilityType.CROSS_SITE_SCRIPTING]:
            return "input_validation"
        elif finding.vulnerability_type in [VulnerabilityType.CRYPTOGRAPHIC_FAILURES]:
            return "cryptography_fixes"
        else:
            return "code_changes"
    
    def _identify_priority_findings(self, findings: List[VulnerabilityFinding]) -> List[VulnerabilityFinding]:
        """Identify highest priority findings for immediate attention."""
        # Priority criteria: Critical severity, high confidence, exploit availability
        priority_findings = []
        
        for finding in findings:
            priority_score = 0
            
            # Severity weight
            severity_weights = {
                SecurityTestSeverity.CRITICAL: 40,
                SecurityTestSeverity.HIGH: 25,
                SecurityTestSeverity.MEDIUM: 10,
                SecurityTestSeverity.LOW: 5
            }
            priority_score += severity_weights.get(finding.severity, 0)
            
            # Confidence weight
            priority_score += finding.confidence * 20
            
            # Threat level weight
            threat_weights = {
                ThreatLevel.CRITICAL: 30,
                ThreatLevel.HIGH: 20,
                ThreatLevel.MEDIUM: 10,
                ThreatLevel.LOW: 5
            }
            priority_score += threat_weights.get(finding.threat_level, 0)
            
            # CVSS score weight
            if finding.cvss_score:
                priority_score += finding.cvss_score
            
            finding.custom_fields['priority_score'] = priority_score
            
            # Consider high priority if score > 60
            if priority_score > 60:
                priority_findings.append(finding)
        
        # Sort by priority score
        priority_findings.sort(key=lambda f: f.custom_fields.get('priority_score', 0), reverse=True)
        
        return priority_findings[:20]  # Top 20 priority findings
    
    def _generate_recommended_actions(self, findings: List[VulnerabilityFinding]) -> List[str]:
        """Generate high-level recommended actions."""
        actions = []
        
        # Analyze findings patterns
        severity_counts = self._count_by_severity(findings)
        type_counts = self._count_by_type(findings)
        
        # Critical actions for critical findings
        if severity_counts.get('critical', 0) > 0:
            actions.append("IMMEDIATE: Address all critical vulnerabilities within 24 hours")
        
        # High-impact actions
        if severity_counts.get('high', 0) > 0:
            actions.append("HIGH PRIORITY: Remediate high-severity vulnerabilities within 7 days")
        
        # Specific recommendations based on vulnerability types
        if type_counts.get('vulnerable_components', 0) > 0:
            actions.append("Update vulnerable dependencies and establish dependency management process")
        
        if type_counts.get('sql_injection', 0) > 0 or type_counts.get('cross_site_scripting', 0) > 0:
            actions.append("Implement comprehensive input validation and output encoding")
        
        if type_counts.get('flask_security_headers', 0) > 0:
            actions.append("Configure Flask-Talisman security headers for comprehensive protection")
        
        if type_counts.get('authentication_failures', 0) > 0:
            actions.append("Review and strengthen authentication mechanisms")
        
        # General recommendations
        actions.append("Establish regular security scanning as part of CI/CD pipeline")
        actions.append("Conduct security training for development team")
        actions.append("Implement security code review process")
        
        return actions
    
    def _count_by_severity(self, findings: List[VulnerabilityFinding]) -> Dict[str, int]:
        """Count findings by severity level."""
        counts = {}
        for finding in findings:
            severity = finding.severity.value
            counts[severity] = counts.get(severity, 0) + 1
        return counts
    
    def _count_by_type(self, findings: List[VulnerabilityFinding]) -> Dict[str, int]:
        """Count findings by vulnerability type."""
        counts = {}
        for finding in findings:
            vuln_type = finding.vulnerability_type.value
            counts[vuln_type] = counts.get(vuln_type, 0) + 1
        return counts
    
    def _record_scan_metrics(self, scan_result: ScanResult):
        """Record scan metrics for monitoring."""
        # Record scan execution metrics
        vulnerability_metrics['vulnerability_scans_executed'].labels(
            scan_type='comprehensive',
            target_type=scan_result.scan_configuration.target_type,
            severity='all'
        ).inc()
        
        # Record vulnerabilities discovered
        for finding in scan_result.findings:
            vulnerability_metrics['vulnerabilities_discovered'].labels(
                vulnerability_type=finding.vulnerability_type.value,
                severity=finding.severity.value,
                source=finding.detection_algorithm
            ).inc()
        
        # Record compliance results
        for framework, result in scan_result.compliance_results.items():
            status = 'compliant' if result.get('compliant', False) else 'non_compliant'
            vulnerability_metrics['compliance_validation_results'].labels(
                framework=framework.value,
                requirement='overall',
                status=status
            ).inc()
    
    def generate_scan_report(self, scan_result: ScanResult, output_format: str = 'json') -> str:
        """
        Generate comprehensive scan report in specified format.
        
        Args:
            scan_result: Scan result to generate report for
            output_format: Output format ('json', 'html', 'pdf', 'xml')
            
        Returns:
            Formatted scan report
        """
        if output_format.lower() == 'json':
            return self._generate_json_report(scan_result)
        elif output_format.lower() == 'html':
            return self._generate_html_report(scan_result)
        else:
            raise ValueError(f"Unsupported output format: {output_format}")
    
    def _generate_json_report(self, scan_result: ScanResult) -> str:
        """Generate JSON format scan report."""
        # Convert scan result to serializable format
        report_data = asdict(scan_result)
        
        # Convert datetime objects to ISO format
        report_data['start_time'] = scan_result.start_time.isoformat()
        report_data['end_time'] = scan_result.end_time.isoformat()
        
        # Convert findings to serializable format
        findings_data = []
        for finding in scan_result.findings:
            finding_data = asdict(finding)
            finding_data['scan_timestamp'] = finding.scan_timestamp.isoformat()
            finding_data['vulnerability_type'] = finding.vulnerability_type.value
            finding_data['severity'] = finding.severity.value
            finding_data['threat_level'] = finding.threat_level.value
            finding_data['scanning_technique'] = finding.scanning_technique.value
            finding_data['affected_compliance_frameworks'] = [f.value for f in finding.affected_compliance_frameworks]
            findings_data.append(finding_data)
        
        report_data['findings'] = findings_data
        
        # Convert compliance results
        compliance_data = {}
        for framework, result in scan_result.compliance_results.items():
            compliance_data[framework.value] = result
        report_data['compliance_results'] = compliance_data
        
        return json.dumps(report_data, indent=2, default=str)
    
    def _generate_html_report(self, scan_result: ScanResult) -> str:
        """Generate HTML format scan report."""
        # This would generate a comprehensive HTML report
        # For brevity, returning a simplified template
        
        html_template = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Vulnerability Scan Report - {scan_result.scan_id}</title>
            <meta charset="utf-8">
            <style>
                body {{ font-family: Arial, sans-serif; margin: 40px; }}
                .header {{ background-color: #f8f9fa; padding: 20px; border-radius: 5px; }}
                .summary {{ margin: 20px 0; }}
                .finding {{ border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }}
                .critical {{ border-left: 5px solid #dc3545; }}
                .high {{ border-left: 5px solid #fd7e14; }}
                .medium {{ border-left: 5px solid #ffc107; }}
                .low {{ border-left: 5px solid #28a745; }}
                .compliance {{ background-color: #e7f3ff; padding: 15px; margin: 10px 0; border-radius: 5px; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>Vulnerability Scan Report</h1>
                <p><strong>Scan ID:</strong> {scan_result.scan_id}</p>
                <p><strong>Start Time:</strong> {scan_result.start_time.strftime('%Y-%m-%d %H:%M:%S UTC')}</p>
                <p><strong>Duration:</strong> {scan_result.scan_duration:.2f} seconds</p>
                <p><strong>Security Posture Score:</strong> {scan_result.security_posture_score:.1f}/100</p>
            </div>
            
            <div class="summary">
                <h2>Executive Summary</h2>
                <p><strong>Total Vulnerabilities:</strong> {scan_result.total_vulnerabilities}</p>
                <p><strong>Critical:</strong> {scan_result.vulnerabilities_by_severity.get('critical', 0)}</p>
                <p><strong>High:</strong> {scan_result.vulnerabilities_by_severity.get('high', 0)}</p>
                <p><strong>Medium:</strong> {scan_result.vulnerabilities_by_severity.get('medium', 0)}</p>
                <p><strong>Low:</strong> {scan_result.vulnerabilities_by_severity.get('low', 0)}</p>
            </div>
            
            <div class="findings">
                <h2>Priority Findings</h2>
                {''.join(self._format_finding_html(finding) for finding in scan_result.priority_findings[:10])}
            </div>
            
            <div class="compliance">
                <h2>Compliance Assessment</h2>
                {''.join(f'<p><strong>{framework.value}:</strong> {result["compliance_score"]:.1f}% compliant</p>' 
                        for framework, result in scan_result.compliance_results.items())}
            </div>
            
            <div class="recommendations">
                <h2>Recommended Actions</h2>
                <ul>
                    {''.join(f'<li>{action}</li>' for action in scan_result.recommended_actions)}
                </ul>
            </div>
        </body>
        </html>
        """
        
        return html_template
    
    def _format_finding_html(self, finding: VulnerabilityFinding) -> str:
        """Format individual finding for HTML report."""
        severity_class = finding.severity.value.lower()
        
        return f"""
        <div class="finding {severity_class}">
            <h3>{finding.title}</h3>
            <p><strong>Severity:</strong> {finding.severity.value.title()}</p>
            <p><strong>Confidence:</strong> {finding.confidence:.1%}</p>
            <p><strong>Type:</strong> {finding.vulnerability_type.value.replace('_', ' ').title()}</p>
            <p><strong>Description:</strong> {finding.description}</p>
            {f'<p><strong>File:</strong> {finding.file_path}:{finding.line_number}</p>' if finding.file_path else ''}
            {f'<p><strong>URL:</strong> {finding.url_endpoint}</p>' if finding.url_endpoint else ''}
            <p><strong>Remediation:</strong> {finding.remediation_guidance}</p>
            {f'<p><strong>Proof of Concept:</strong> <code>{finding.proof_of_concept}</code></p>' if finding.proof_of_concept else ''}
        </div>
        """


# Integration functions for testing infrastructure
async def create_vulnerability_scanner(security_config: Optional[SecurityTestConfiguration] = None) -> VulnerabilityScanner:
    """
    Create and initialize vulnerability scanner instance.
    
    Args:
        security_config: Optional security configuration, uses default if not provided
        
    Returns:
        Initialized vulnerability scanner
    """
    if security_config is None:
        security_config = SecurityTestConfiguration()
    
    return VulnerabilityScanner(security_config)


def create_default_scan_config(target_url: str = None, target_path: str = None) -> ScanConfiguration:
    """
    Create default scan configuration for common use cases.
    
    Args:
        target_url: Target URL for dynamic analysis
        target_path: Target path for static analysis
        
    Returns:
        Default scan configuration
    """
    scan_id = f"default_scan_{uuid.uuid4().hex[:8]}"
    
    return ScanConfiguration(
        scan_id=scan_id,
        scan_name="Default Security Scan",
        target_type="application",
        target_url=target_url,
        target_path=target_path,
        enabled_techniques=[
            ScanningTechnique.STATIC_ANALYSIS,
            ScanningTechnique.DYNAMIC_ANALYSIS,
            ScanningTechnique.DEPENDENCY_SCANNING,
            ScanningTechnique.PENETRATION_TESTING
        ],
        vulnerability_types=[vt for vt in VulnerabilityType],
        compliance_frameworks=[
            ComplianceFramework.OWASP_TOP10,
            ComplianceFramework.SOC2_TYPE2
        ],
        max_scan_duration=3600,
        max_concurrent_scans=5,
        rate_limit_delay=1.0,
        detailed_reporting=True,
        output_formats=["json", "html"]
    )


# Pytest fixtures for vulnerability scanner integration
@pytest.fixture(scope="session")
async def vulnerability_scanner(security_test_config):
    """Pytest fixture providing vulnerability scanner instance."""
    return await create_vulnerability_scanner(security_test_config)


@pytest.fixture(scope="function")
def scan_config(request):
    """Pytest fixture providing scan configuration."""
    target_url = getattr(request, 'param', {}).get('target_url')
    target_path = getattr(request, 'param', {}).get('target_path')
    return create_default_scan_config(target_url, target_path)


# Export main components
__all__ = [
    'VulnerabilityScanner',
    'VulnerabilityDatabase',
    'StaticAnalysisScanner',
    'DynamicAnalysisScanner', 
    'DependencyScanner',
    'VulnerabilityFinding',
    'ScanConfiguration',
    'ScanResult',
    'VulnerabilityType',
    'ScanningTechnique',
    'ThreatLevel',
    'create_vulnerability_scanner',
    'create_default_scan_config',
    'vulnerability_metrics'
]